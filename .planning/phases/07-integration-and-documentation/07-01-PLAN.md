---
phase: 07-integration-and-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/helpers/neuron-harness.ts
  - tests/e2e-lifecycle.test.ts
autonomous: true
requirements: [INTG-01]

must_haves:
  truths:
    - "E2E test passes: init storage, register with mock Axon, add provider, patient connects via WebSocket, consent handshake completes, session established, relationship terminated"
    - "Test harness composes all Neuron subsystems in the same order as start.ts without spawning a child process"
    - "WebSocket handshake helpers are reusable from tests/helpers/ for subsequent E2E test suites"
  artifacts:
    - path: "tests/helpers/neuron-harness.ts"
      provides: "NeuronTestHarness composing all subsystems with start/stop lifecycle"
      exports: ["NeuronTestHarness"]
    - path: "tests/e2e-lifecycle.test.ts"
      provides: "Full lifecycle E2E test validating ROADMAP SC-1"
      contains: "describe.*lifecycle"
  key_links:
    - from: "tests/helpers/neuron-harness.ts"
      to: "src/cli/commands/start.ts"
      via: "Same initialization order: storage -> audit -> ipc -> registration -> relationships -> protocolServer -> REST -> discovery"
      pattern: "SqliteStorage.*AuditLogger.*AxonRegistrationService.*RelationshipStore.*NeuronProtocolServer"
    - from: "tests/e2e-lifecycle.test.ts"
      to: "tests/helpers/neuron-harness.ts"
      via: "import NeuronTestHarness"
      pattern: "import.*NeuronTestHarness"
    - from: "tests/e2e-lifecycle.test.ts"
      to: "ws://127.0.0.1:{port}/ws/handshake"
      via: "Real WebSocket connection for consent handshake"
      pattern: "new WebSocket.*ws://127\\.0\\.0\\.1"
---

<objective>
Build a composable E2E test harness and the full lifecycle integration test.

Purpose: The harness extracts the Neuron startup/teardown lifecycle (mirroring start.ts) into a reusable class for all three E2E test suites. The lifecycle test validates ROADMAP Phase 7 Success Criterion 1: full lifecycle from init through register, add provider, patient connect, consent handshake, session, and termination.

Output: `tests/helpers/neuron-harness.ts` (shared harness), `tests/e2e-lifecycle.test.ts` (lifecycle E2E test)
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-integration-and-documentation/07-RESEARCH.md

# Key source files for harness composition
@src/cli/commands/start.ts
@src/routing/routing.test.ts
@test/mock-axon/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NeuronTestHarness and WebSocket helpers</name>
  <files>tests/helpers/neuron-harness.ts</files>
  <action>
Create a `NeuronTestHarness` class that composes all Neuron subsystems in the same order as `src/cli/commands/start.ts` without spawning a CLI child process.

**Harness interface:**
```typescript
interface HarnessOptions {
  enableDiscovery?: boolean      // default false
  enableAxonMock?: boolean       // default true
  rateLimit?: { maxRequests: number; windowMs: number }
  heartbeatIntervalMs?: number   // default 999999 (never fire in tests)
}

class NeuronTestHarness {
  // Exposed for test assertions
  storage: SqliteStorage
  auditLogger: AuditLogger
  registrationService: AxonRegistrationService
  relationshipStore: RelationshipStore
  handshakeHandler: ConsentHandshakeHandler
  protocolServer: NeuronProtocolServer
  apiKeyStore: ApiKeyStore
  rateLimiter: TokenBucketRateLimiter
  discoveryService?: DiscoveryService
  mockAxonServer?: http.Server
  config: NeuronConfig
  port: number  // Ephemeral port after start

  async start(options?: HarnessOptions): Promise<void>
  async stop(): Promise<void>
}
```

**Initialization order (matching start.ts):**
1. Start mock Axon server on port 0, extract ephemeral port
2. Build NeuronConfig with `storage.path: ':memory:'`, `server.port: 0`, `axon.registryUrl` pointing to mock Axon, `heartbeat.intervalMs: 999999`
3. Create SqliteStorage (in-memory), call `initialize()`
4. Create AuditLogger with temp directory path
5. Create AxonRegistrationService, RelationshipStore, ConsentHandshakeHandler
6. Create NeuronProtocolServer, createConnectionHandler, wire together
7. Start protocolServer on port 0, extract ephemeral port into `this.port`
8. Create ApiKeyStore, TokenBucketRateLimiter, createApiRouter, attach to HTTP server
9. If enableDiscovery: create and start DiscoveryService
10. Start registrationService

**Shutdown order (matching start.ts):**
1. Stop discovery (if enabled)
2. Stop protocolServer
3. Stop registrationService
4. Close storage
5. Close mock Axon server
6. Remove temp directory

**Also export WebSocket helper functions** (extracted from `src/routing/routing.test.ts`):
- `makeTestKeyPair()` -- generates Ed25519 key pair, returns `{ publicKey, privateKey, publicKeyBase64url }`
- `signConsentToken(claims, privateKey)` -- signs claims payload, returns `{ payload, signature }`
- `validClaims(patientAgentId, providerNpi)` -- returns properly-formed consent claims with 1-hour expiry
- `connectAndWaitOpen(port)` -- creates WebSocket client to `ws://127.0.0.1:{port}/ws/handshake`, resolves on open
- `receiveMessage(ws)` -- receives single JSON message with 5-second timeout
- `waitForClose(ws)` -- waits for WebSocket close event, returns `{ code, reason }`
- `sendAuthMessage(ws, token, publicKeyBase64url)` -- sends the `handshake.auth` typed envelope

Use `mkdtempSync` for audit log temp directory. Use `rmSync` with `{ recursive: true, force: true }` for cleanup.

**Important:** The mock Axon server uses `createMockAxonServer(0)` from `test/mock-axon/server.ts`. Await the `listening` event before extracting the port with `server.address()`. The config must be constructed AFTER mock Axon starts because the port is needed for `registryUrl`.

The harness uses `beforeAll`/`afterAll` lifecycle (not `beforeEach`) per Axon's test pattern -- it's expensive to create and tests can share it, resetting state between tests where needed.
  </action>
  <verify>
`npx tsc --noEmit` compiles without errors. The harness file exports NeuronTestHarness, makeTestKeyPair, signConsentToken, validClaims, connectAndWaitOpen, receiveMessage, waitForClose, sendAuthMessage.
  </verify>
  <done>NeuronTestHarness class exists with start/stop lifecycle mirroring start.ts, all WebSocket helper functions exported, TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create full lifecycle E2E test</name>
  <files>tests/e2e-lifecycle.test.ts</files>
  <action>
Create the full lifecycle E2E test validating ROADMAP Phase 7 Success Criterion 1:
> "E2E test passes: full lifecycle from init through register, add provider, patient connect, consent handshake, session, and termination"

**Test structure using `beforeAll`/`afterAll` for harness:**

```typescript
describe('E2E: Full Lifecycle', () => {
  let harness: NeuronTestHarness

  beforeAll(async () => {
    harness = new NeuronTestHarness()
    await harness.start()
  })

  afterAll(async () => {
    await harness.stop()
  })

  // Tests below
})
```

**Test cases (in execution order -- each builds on the state from prior tests):**

1. **"initializes storage and registers with Axon"**
   - Assert `harness.registrationService.getStatus()` has a non-null `neuron.registration_id`
   - Assert registration status is not 'unregistered'

2. **"adds a provider via registration service"**
   - Call `await harness.registrationService.addProvider('1234567890')` (valid NPI)
   - Assert `harness.registrationService.listProviders()` has length >= 1
   - Assert the added provider's NPI matches

3. **"patient connects via WebSocket and completes consent handshake"**
   - Generate test key pair with `makeTestKeyPair()`
   - Create valid claims for `patient-agent-001` and provider NPI `1234567890`
   - Sign the consent token with `signConsentToken()`
   - Connect via `connectAndWaitOpen(harness.port)`
   - Send auth message with `sendAuthMessage(ws, token, publicKeyBase64url)`
   - Receive challenge message via `receiveMessage(ws)` -- assert `type === 'handshake.challenge'` and `nonce` exists
   - Sign the challenge nonce with the patient's private key: `sign(null, Buffer.from(challenge.nonce, 'base64url'), privateKey).toString('base64url')`
   - Send challenge response: `ws.send(JSON.stringify({ type: 'handshake.challenge_response', challenge_response: signedNonce }))`
   - Receive completion message via `receiveMessage(ws)` -- assert `type === 'handshake.complete'` and `relationship_id` exists
   - Wait for close via `waitForClose(ws)` -- assert code is 1000 (normal close, broker-and-step-out)
   - Store `relationship_id` for subsequent tests

4. **"relationship persists in store after handshake"**
   - Query `harness.relationshipStore.findById(relationship_id)` -- assert record exists
   - Assert status is 'active'
   - Assert patient_agent_id is `patient-agent-001`
   - Assert provider_npi is `1234567890`

5. **"terminates relationship"**
   - Use a TerminationHandler instance: `new TerminationHandler(harness.storage, harness.relationshipStore, harness.auditLogger)`
   - Call `terminationHandler.terminate(relationship_id, '1234567890', 'Patient discharged')`
   - Query `harness.relationshipStore.findById(relationship_id)` -- assert status is 'terminated'

6. **"terminated relationship blocks new connections"**
   - Generate a new key pair (or reuse) and sign a new consent token for same patient/provider
   - Connect via WebSocket, send auth message
   - Receive challenge, complete challenge-response
   - Receive error or completion with existing relationship check -- since relationship is terminated, the handshake should fail or return an error. Assert the connection is closed with an appropriate error code.

7. **"audit trail records lifecycle events"**
   - Verify `harness.auditLogger` has logged events by reading the audit file
   - OR check that multiple entries exist in the audit log file (at least: neuron_start, registration, consent, termination)

Import TerminationHandler from `'../../src/relationships/index.js'` (or appropriate path).

**Key patterns:**
- Use `{ timeout: 15000 }` on the describe or individual tests to allow for network latency
- The NPI `1234567890` must pass Luhn validation -- verify this is a valid NPI or use one known to be valid (e.g., `9999999999` which is used in config, or `1234567893` which has valid Luhn). Use the org NPI from the harness config for the provider NPI to simplify, or compute a valid Luhn NPI. Research note: the config already uses `9999999999` as org NPI. Use a different valid NPI for the provider -- the mock Axon accepts any NPI.
  </action>
  <verify>
Run `npx vitest run tests/e2e-lifecycle.test.ts` -- all tests pass. Verify test covers: registration, provider add, WebSocket connect, consent handshake, relationship persistence, termination, and terminated-relationship rejection.
  </verify>
  <done>Full lifecycle E2E test passes, covering init -> register -> add provider -> patient connect -> consent handshake -> session -> terminate -> terminated rejection. All ROADMAP SC-1 criteria validated.</done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/e2e-lifecycle.test.ts` passes with all test cases green
2. `npx tsc --noEmit` compiles without errors
3. Existing tests still pass: `npx vitest run src/`
</verification>

<success_criteria>
- NeuronTestHarness composes all subsystems without CLI child process
- Full lifecycle E2E test validates every step from ROADMAP SC-1
- WebSocket helpers are reusable for Plan 02's tests
- All tests pass including existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/07-integration-and-documentation/07-01-SUMMARY.md`
</output>
