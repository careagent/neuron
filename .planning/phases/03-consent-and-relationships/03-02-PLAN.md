---
phase: 03-consent-and-relationships
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/relationships/store.ts
  - src/relationships/handshake.ts
  - src/consent/challenge.ts
  - src/relationships/index.ts
  - src/relationships/relationships.test.ts
autonomous: true
requirements:
  - RELN-01
  - RELN-02
  - RELN-03
  - RELN-04

must_haves:
  truths:
    - "A consent handshake between a patient CareAgent and a provider creates a RelationshipRecord that persists across restarts"
    - "Relationships can be queried by patient agent ID, provider NPI, relationship ID, and status"
    - "Challenge-response proves patient identity by signing a nonce with their Ed25519 private key"
    - "A completed handshake returns a relationship_id and the relationship has status 'active'"
    - "Expired or unknown challenge nonces are rejected"
  artifacts:
    - path: "src/relationships/store.ts"
      provides: "RelationshipRecord SQLite CRUD and queries"
      exports: ["RelationshipStore"]
    - path: "src/relationships/handshake.ts"
      provides: "Consent handshake handler (Neuron side)"
      exports: ["ConsentHandshakeHandler"]
    - path: "src/consent/challenge.ts"
      provides: "Challenge nonce generation and signature verification"
      exports: ["generateChallenge", "verifyChallenge"]
    - path: "src/relationships/index.ts"
      provides: "Public barrel exports"
    - path: "src/relationships/relationships.test.ts"
      provides: "Unit tests for store and handshake"
  key_links:
    - from: "src/relationships/store.ts"
      to: "src/storage/interface.ts"
      via: "StorageEngine SQL operations"
      pattern: "this\\.storage\\.(run|get|all)"
    - from: "src/relationships/handshake.ts"
      to: "src/consent/verifier.ts"
      via: "verifyConsentToken for token validation"
      pattern: "verifyConsentToken"
    - from: "src/relationships/handshake.ts"
      to: "src/relationships/store.ts"
      via: "store.create for relationship persistence"
      pattern: "this\\.store\\.create"
    - from: "src/relationships/handshake.ts"
      to: "src/consent/challenge.ts"
      via: "generateChallenge + verifyChallenge for identity proof"
      pattern: "(generateChallenge|verifyChallenge)"
---

<objective>
Build the RelationshipStore for persistent CRUD/queries and the ConsentHandshakeHandler that orchestrates the multi-step handshake protocol to establish care relationships.

Purpose: Relationships are the trust records that gate all routing. The store persists them in SQLite (surviving restarts), and the handshake handler coordinates challenge-response identity verification with consent token validation to create new relationships securely.

Output: RelationshipStore with full query support, challenge-response utilities, and ConsentHandshakeHandler implementing the Neuron side of the Axon protocol handshake.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-consent-and-relationships/03-RESEARCH.md
@.planning/phases/03-consent-and-relationships/03-01-SUMMARY.md

@src/storage/interface.ts
@src/types/relationship.ts
@src/registration/state.ts
@src/consent/verifier.ts
@src/consent/errors.ts
@src/consent/token.ts
@src/audit/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RelationshipStore CRUD and query methods</name>
  <files>src/relationships/store.ts</files>
  <action>
    Create `src/relationships/store.ts` following the `RegistrationStateStore` pattern from `src/registration/state.ts`.

    **Constructor:** Takes `StorageEngine` instance.

    **Row interface:** `RelationshipRow` with all columns as strings (SQLite returns TEXT). `consented_actions` is stored as JSON string, `patient_public_key` as base64url string.

    **Methods:**
    1. `create(record: RelationshipRecord): void` -- INSERT into relationships table. `JSON.stringify(record.consented_actions)` for the consented_actions column.
    2. `findById(relationshipId: string): RelationshipRecord | undefined` -- SELECT by relationship_id.
    3. `findByPatient(patientAgentId: string): RelationshipRecord[]` -- SELECT by patient_agent_id.
    4. `findByProvider(providerNpi: string): RelationshipRecord[]` -- SELECT by provider_npi.
    5. `findByStatus(status: string): RelationshipRecord[]` -- SELECT by status.
    6. `updateStatus(relationshipId: string, status: string): void` -- UPDATE status. CRITICAL: Must check current status first and throw if `status === 'terminated'` with message "Cannot update status of a terminated relationship" (TERM-04 enforcement at store layer).

    **Private helper:** `rowToRecord(row: RelationshipRow): RelationshipRecord` -- Converts SQLite row to typed record. `JSON.parse(row.consented_actions)` for the array field, cast `row.status` as `RelationshipRecord['status']`.

    Import `StorageEngine` from `../storage/interface.js` and `RelationshipRecord` from `../types/relationship.js`. Use `.js` extensions for ESM.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Store methods match the RegistrationStateStore pattern
  </verify>
  <done>
    RelationshipStore provides create, findById, findByPatient, findByProvider, findByStatus, and updateStatus methods. Terminated status transitions are rejected at the store level.
  </done>
</task>

<task type="auto">
  <name>Task 2: Challenge-response utilities and ConsentHandshakeHandler</name>
  <files>src/consent/challenge.ts, src/relationships/handshake.ts, src/relationships/index.ts, src/relationships/relationships.test.ts</files>
  <action>
    **src/consent/challenge.ts:**
    Create challenge-response utilities for identity verification (RELN-04).
    1. `generateChallenge(): string` -- Returns `randomBytes(32).toString('hex')`. 32 bytes = 256 bits of entropy.
    2. `verifyChallenge(nonce: string, signedNonce: Buffer, publicKey: KeyObject): boolean` -- Converts hex nonce to Buffer, calls `verify(null, nonceBuffer, publicKey, signedNonce)`. Returns boolean. Algorithm parameter MUST be `null` for Ed25519.
    Import `randomBytes`, `verify`, and `KeyObject` from `node:crypto`. Re-export from `src/consent/index.ts`.

    **src/relationships/handshake.ts:**
    Create `ConsentHandshakeHandler` class implementing the Neuron side of the handshake protocol.

    **Interfaces (exported):**
    - `HandshakeInit`: `{ patient_agent_id: string, provider_npi: string, patient_public_key: string }`
    - `HandshakeChallenge`: `{ nonce: string, provider_npi: string, organization_npi: string }`
    - `ChallengeResponse`: `{ signed_nonce: string, consent_token_payload: string, consent_token_signature: string }` (all base64url)

    **Constructor:** Takes `RelationshipStore`, `organizationNpi: string`, optional `AuditLogger`.

    **Private state:** `pendingChallenges: Map<string, { init: HandshakeInit, expiresAt: number }>` -- in-memory map of in-flight challenges.

    **Methods:**
    1. `startHandshake(init: HandshakeInit): HandshakeChallenge` -- Generate challenge nonce via `generateChallenge()`, store in pendingChallenges with 30-second TTL (`Date.now() + 30_000`), call `cleanExpiredChallenges()`, return challenge object. Hard cap: if pendingChallenges.size >= 1000, throw Error("Too many pending handshakes") to prevent memory exhaustion.

    2. `completeHandshake(nonce: string, response: ChallengeResponse): string` -- (a) Look up nonce in pendingChallenges, throw ConsentError MALFORMED_TOKEN if not found; (b) check TTL, throw ConsentError CONSENT_EXPIRED if expired; (c) delete from map; (d) import patient public key via `importPublicKey(init.patient_public_key)`; (e) verify challenge-response: call `verifyChallenge(nonce, Buffer.from(response.signed_nonce, 'base64url'), publicKey)`, throw ConsentError INVALID_SIGNATURE if false; (f) verify consent token: `verifyConsentToken({ payload: Buffer.from(response.consent_token_payload, 'base64url'), signature: Buffer.from(response.consent_token_signature, 'base64url') }, publicKey)`; (g) validate claims.provider_npi matches init.provider_npi, throw MALFORMED_TOKEN if not; (h) create RelationshipRecord via `this.store.create()` with `randomUUID()` as relationship_id, status 'active', claims.consented_actions, init.patient_public_key; (i) log audit event with category 'consent', action 'consent.relationship_established'; (j) return relationship_id.

    3. `cleanExpiredChallenges(): void` -- private. Iterate pendingChallenges, delete entries where `Date.now() > expiresAt`.

    Import from `node:crypto`: `randomUUID`. Import `verifyConsentToken`, `importPublicKey`, `ConsentError` from `../consent/verifier.js`. Import `generateChallenge`, `verifyChallenge` from `../consent/challenge.js`. Import types from `../consent/token.js`. Import `RelationshipStore` from `./store.js`. Import `AuditLogger` and `AuditEvent` from `../audit/logger.js`.

    **src/relationships/index.ts:**
    Re-export `RelationshipStore` from `./store.js` and `ConsentHandshakeHandler`, `HandshakeInit`, `HandshakeChallenge`, `ChallengeResponse` from `./handshake.js`.

    **src/relationships/relationships.test.ts:**
    Test with `vitest`. Use `SqliteStorage` (in-memory `:memory:`) for real database tests.

    Test groups:
    1. **RelationshipStore:**
       - create + findById round-trip
       - findByPatient returns matching records
       - findByProvider returns matching records
       - findByStatus returns matching records
       - updateStatus changes status
       - updateStatus on terminated relationship throws
       - findById returns undefined for nonexistent
       - consented_actions serialized/deserialized correctly as JSON array

    2. **ConsentHandshakeHandler:**
       - Full handshake flow: startHandshake -> sign nonce -> create consent token -> completeHandshake -> returns relationship_id -> findById confirms record
       - Expired challenge nonce rejects with CONSENT_EXPIRED
       - Unknown nonce rejects with MALFORMED_TOKEN
       - Invalid challenge signature rejects with INVALID_SIGNATURE
       - Provider NPI mismatch in token rejects with MALFORMED_TOKEN
       - Pending challenges map is cleaned up after expiry

    Use `generateKeyPairSync('ed25519')` for test keys. Sign nonces with `sign(null, Buffer.from(nonce, 'hex'), privateKey)`. Create consent tokens with the `signConsentToken` test helper pattern from the research.
  </action>
  <verify>
    - `npx vitest run src/relationships/` passes
    - `npx vitest run src/consent/` still passes
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    RelationshipStore persists records in SQLite and supports all four query dimensions (patient, provider, id, status). ConsentHandshakeHandler orchestrates the full challenge-response + consent verification handshake and creates active relationships. Challenge nonces have 30s TTL and are cleaned up. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/relationships/` -- all relationship tests pass
- `npx vitest run src/consent/` -- all consent tests still pass
- `npx vitest run` -- all project tests pass
- `npx tsc --noEmit` -- no type errors
</verification>

<success_criteria>
- RelationshipStore creates, reads, queries, and updates relationships in SQLite
- Terminated status cannot be changed via updateStatus (store-level enforcement)
- Full handshake flow works: init -> challenge -> response -> relationship created
- Challenge-response proves patient identity via Ed25519 nonce signing
- Consent token is verified during handshake (delegates to ConsentVerifier from Plan 01)
- Provider NPI mismatch between token claims and handshake init is rejected
- Challenge nonces expire after 30 seconds with cleanup
- Audit event logged on relationship establishment
- All relationship data survives through SQLite persistence
</success_criteria>

<output>
After completion, create `.planning/phases/03-consent-and-relationships/03-02-SUMMARY.md`
</output>
