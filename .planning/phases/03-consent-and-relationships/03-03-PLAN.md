---
phase: 03-consent-and-relationships
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/relationships/termination.ts
  - src/relationships/termination.test.ts
  - src/relationships/index.ts
  - src/ipc/protocol.ts
  - src/cli/commands/start.ts
autonomous: true
requirements:
  - TERM-01
  - TERM-02
  - TERM-03
  - TERM-04

must_haves:
  truths:
    - "A provider-initiated termination permanently sets relationship status to 'terminated'"
    - "A terminated relationship cannot be reactivated or have its status changed"
    - "A TerminationRecord is persisted with the reason and audit trail linkage"
    - "Termination and status update happen atomically in a single transaction"
    - "A new consent handshake for a previously terminated patient-provider pair creates a new relationship (new relationship_id)"
    - "The termination command is accessible via IPC from the running Neuron"
  artifacts:
    - path: "src/relationships/termination.ts"
      provides: "TerminationHandler with transactional safety"
      exports: ["TerminationHandler"]
    - path: "src/relationships/termination.test.ts"
      provides: "Termination handler unit tests"
    - path: "src/ipc/protocol.ts"
      provides: "Updated IPC command schema with relationship.terminate"
      contains: "relationship.terminate"
  key_links:
    - from: "src/relationships/termination.ts"
      to: "src/storage/interface.ts"
      via: "storage.transaction for atomic termination"
      pattern: "this\\.storage\\.transaction"
    - from: "src/relationships/termination.ts"
      to: "src/audit/logger.ts"
      via: "auditLogger.append for audit trail linkage"
      pattern: "this\\.auditLogger.*\\.append"
    - from: "src/relationships/termination.ts"
      to: "src/relationships/store.ts"
      via: "relationshipStore.findById for validation"
      pattern: "this\\.relationshipStore\\.findById"
    - from: "src/cli/commands/start.ts"
      to: "src/relationships/termination.ts"
      via: "IPC handler dispatches relationship.terminate to TerminationHandler"
      pattern: "relationship\\.terminate"
---

<objective>
Build the TerminationHandler for provider-initiated relationship termination and wire it into the IPC command protocol for runtime access.

Purpose: Termination is the permanent, irreversible end of a care relationship. It must be transactionally safe (status update + record creation + audit linkage in one transaction), enforce the "terminated is permanent" invariant, and be accessible via IPC so the running Neuron can process termination requests.

Output: TerminationHandler with transactional termination, TerminationRecord persistence, audit trail linkage, and IPC integration via `relationship.terminate` command.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-consent-and-relationships/03-RESEARCH.md
@.planning/phases/03-consent-and-relationships/03-02-SUMMARY.md

@src/storage/interface.ts
@src/types/termination.ts
@src/relationships/store.ts
@src/audit/logger.ts
@src/ipc/protocol.ts
@src/cli/commands/start.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TerminationHandler with transactional safety and audit linkage</name>
  <files>src/relationships/termination.ts, src/relationships/termination.test.ts, src/relationships/index.ts</files>
  <action>
    **src/relationships/termination.ts:**
    Create `TerminationHandler` class for provider-initiated termination (TERM-01).

    **Constructor:** Takes `StorageEngine`, `RelationshipStore`, optional `AuditLogger`.

    **Methods:**
    1. `terminate(relationshipId: string, providerNpi: string, reason: string): void` -- All operations inside `this.storage.transaction(() => { ... })` for atomic consistency:
       a. Load relationship via `this.relationshipStore.findById(relationshipId)`. Throw Error if not found: `Relationship ${relationshipId} not found`.
       b. Check if already terminated. Throw Error: `Relationship ${relationshipId} is already terminated` (TERM-02).
       c. Validate provider_npi matches relationship.provider_npi. Throw Error: `Provider NPI does not match relationship`.
       d. Log audit event first (to capture sequence number for linkage): `this.auditLogger?.append({ category: 'termination', action: 'termination.relationship_terminated', actor: providerNpi, details: { relationship_id: relationshipId, reason } })`. Store returned entry for sequence linkage.
       e. Update relationship status directly via SQL (bypass RelationshipStore.updateStatus to avoid double-validation inside transaction): `this.storage.run('UPDATE relationships SET status = ?, updated_at = ? WHERE relationship_id = ?', ['terminated', new Date().toISOString(), relationshipId])`.
       f. Create termination record: `this.storage.run('INSERT INTO termination_records (termination_id, relationship_id, provider_npi, reason, terminated_at, audit_entry_sequence) VALUES (?, ?, ?, ?, ?, ?)', [randomUUID(), relationshipId, providerNpi, reason, new Date().toISOString(), auditEntry?.sequence ?? null])` (TERM-03).

    Import `randomUUID` from `node:crypto`. Import `StorageEngine` from `../storage/interface.js`. Import `RelationshipStore` from `./store.js`. Import `AuditLogger` from `../audit/logger.js`.

    **src/relationships/termination.test.ts:**
    Unit tests with vitest. Use `SqliteStorage` in-memory for real DB tests. Set up a RelationshipStore and create an active relationship in beforeEach.

    Test cases:
    1. **Successful termination** -- terminate an active relationship, verify: relationship status is 'terminated' via findById, termination_records table has entry with correct fields, audit entry was logged.
    2. **Already terminated rejects** -- terminate same relationship twice, second call throws "already terminated".
    3. **Provider NPI mismatch rejects** -- call terminate with wrong NPI, throws "does not match".
    4. **Nonexistent relationship rejects** -- call terminate with unknown ID, throws "not found".
    5. **Transactional atomicity** -- after a failed termination attempt (wrong NPI), relationship status is unchanged (still 'active').
    6. **Terminated relationship cannot change status via store** -- after termination, `store.updateStatus(id, 'active')` throws (verifies TERM-04 at store layer).
    7. **New handshake after termination creates new relationship** -- create a relationship, terminate it, use ConsentHandshakeHandler to create a new one for same patient-provider pair. Verify old relationship is still terminated, new relationship has different relationship_id and status 'active' (TERM-04).

    For test 7, import ConsentHandshakeHandler and use test key generation. This validates the full TERM-04 invariant end-to-end.

    **src/relationships/index.ts:**
    Add re-export of `TerminationHandler` from `./termination.js`.
  </action>
  <verify>
    - `npx vitest run src/relationships/termination.test.ts` passes
    - `npx vitest run src/relationships/` passes (including relationship.test.ts from Plan 02)
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    TerminationHandler terminates relationships transactionally (status update + record + audit in one transaction). Provider NPI validation prevents unauthorized termination. Terminated status is permanent and enforced at both handler and store levels. A new handshake for a terminated pair creates a new relationship with a new ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: IPC protocol extension and start command wiring for relationship.terminate</name>
  <files>src/ipc/protocol.ts, src/cli/commands/start.ts</files>
  <action>
    **src/ipc/protocol.ts:**
    Add `relationship.terminate` command to the `IpcCommandSchema` union. Add a new union member:
    ```
    Type.Object({
      type: Type.Literal('relationship.terminate'),
      relationship_id: Type.String(),
      provider_npi: Type.String(),
      reason: Type.String(),
    })
    ```
    This follows the existing IPC command pattern (discriminated union on `type`).

    **src/cli/commands/start.ts:**
    In the IPC handler function (the switch on `command.type` inside the start command action), add a new case for `'relationship.terminate'`:
    ```
    case 'relationship.terminate': {
      try {
        terminationHandler.terminate(command.relationship_id, command.provider_npi, command.reason)
        return { ok: true, data: { terminated: true, relationship_id: command.relationship_id } }
      } catch (err) {
        return { ok: false, error: (err as Error).message }
      }
    }
    ```

    This requires the TerminationHandler to be instantiated in the start command's setup. Create it alongside the other services:
    1. Import `RelationshipStore` from `../relationships/store.js` and `TerminationHandler` from `../relationships/termination.js`.
    2. After the StorageEngine is initialized and audit logger is created, instantiate: `const relationshipStore = new RelationshipStore(storage)` and `const terminationHandler = new TerminationHandler(storage, relationshipStore, auditLogger)`.
    3. These instances are captured in the IPC handler closure.

    Do NOT add a CLI subcommand for termination yet (that will be driven by WebSocket messages in Phase 4 or added later). The IPC command is the programmatic entry point for the running Neuron process.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx vitest run src/ipc/` passes (existing IPC tests still work)
    - `npx vitest run src/cli/` passes (existing CLI tests still work)
    - `npx vitest run` passes (full test suite)
  </verify>
  <done>
    IPC protocol includes `relationship.terminate` command type. Start command instantiates RelationshipStore and TerminationHandler, and the IPC handler routes `relationship.terminate` to the handler. Termination is accessible at runtime via IPC.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/relationships/` -- all relationship and termination tests pass
- `npx vitest run` -- full test suite passes
- `npx tsc --noEmit` -- no type errors
- IPC protocol schema includes relationship.terminate command type
</verification>

<success_criteria>
- Provider-initiated termination works end-to-end: validate -> audit -> status update -> record create (all in one transaction)
- Terminated relationships cannot be reactivated (enforced at store and handler levels)
- TerminationRecord includes audit_entry_sequence for audit trail linkage
- Wrong provider NPI is rejected before any mutation
- IPC command `relationship.terminate` is routable to the handler
- A new consent handshake after termination creates a completely new relationship
- All existing tests (Phase 1, Phase 2, and Plans 01-02) continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-consent-and-relationships/03-03-SUMMARY.md`
</output>
