---
phase: 01-foundation
plan: 03
type: tdd
wave: 2
depends_on: [01]
files_modified:
  - src/storage/interface.ts
  - src/storage/sqlite.ts
  - src/storage/migrations.ts
  - src/storage/index.ts
  - src/storage/sqlite.test.ts
  - src/audit/logger.ts
  - src/audit/verifier.ts
  - src/audit/serialize.ts
  - src/audit/index.ts
  - src/audit/audit.test.ts
autonomous: true
requirements:
  - FOUN-07
  - AUDT-01
  - AUDT-02
  - AUDT-03
must_haves:
  truths:
    - "SQLite storage initializes with migrations and persists data across close/reopen cycles"
    - "In-memory SQLite mode works for tests without file system side effects"
    - "Every auditable action appends a hash-chained JSONL entry with SHA-256 prev_hash linkage"
    - "Audit chain integrity verification detects tampered or missing entries"
    - "Deterministic JSON serialization produces identical output for objects with different insertion order"
  artifacts:
    - path: "src/storage/interface.ts"
      provides: "StorageEngine interface definition"
      exports: ["StorageEngine"]
    - path: "src/storage/sqlite.ts"
      provides: "better-sqlite3 implementation of StorageEngine"
      exports: ["SqliteStorage"]
    - path: "src/storage/migrations.ts"
      provides: "Schema versioning and migration runner"
      exports: ["runMigrations"]
    - path: "src/audit/logger.ts"
      provides: "Append-only hash-chained JSONL audit logger"
      exports: ["AuditLogger"]
    - path: "src/audit/verifier.ts"
      provides: "Audit chain integrity verification"
      exports: ["verifyAuditChain"]
    - path: "src/audit/serialize.ts"
      provides: "Deterministic JSON canonicalization"
      exports: ["canonicalize"]
  key_links:
    - from: "src/audit/logger.ts"
      to: "src/audit/serialize.ts"
      via: "imports canonicalize for deterministic hashing"
      pattern: "import.*canonicalize"
    - from: "src/audit/verifier.ts"
      to: "src/audit/serialize.ts"
      via: "uses same canonicalize function to recompute hashes"
      pattern: "import.*canonicalize"
    - from: "src/storage/sqlite.ts"
      to: "src/storage/migrations.ts"
      via: "runs migrations on initialize()"
      pattern: "runMigrations"
---

<objective>
Implement the storage abstraction with SQLite and the tamper-evident hash-chained audit logging system (TDD).

Purpose: Storage and audit logging are the two persistence pillars of the Neuron. The storage engine provides a thin SQLite abstraction with in-memory mode for tests. The audit logger produces hash-chained JSONL entries where each entry's integrity is linked to the previous via SHA-256, enabling offline tamper detection. Both are TDD candidates: deterministic serialization and hash chain verification have well-defined I/O contracts.

Output: Working storage engine with migrations and a verified hash-chained audit log system.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Storage abstraction interface with SQLite implementation and migrations</name>
  <files>
    src/storage/interface.ts
    src/storage/sqlite.ts
    src/storage/migrations.ts
    src/storage/index.ts
    src/storage/sqlite.test.ts
  </files>
  <action>
    Build a thin storage abstraction over better-sqlite3.

    **src/storage/interface.ts:**
    Define `StorageEngine` interface:
    ```typescript
    interface StorageEngine {
      initialize(): void        // Run migrations, set up tables
      close(): void             // Close database connection
      run(sql: string, params?: unknown[]): RunResult
      get<T>(sql: string, params?: unknown[]): T | undefined
      all<T>(sql: string, params?: unknown[]): T[]
      transaction<T>(fn: () => T): T
    }

    interface RunResult {
      changes: number
      lastInsertRowid: number | bigint
    }
    ```
    Keep it thin -- do NOT create repository classes per entity. Raw SQL through the interface is the correct abstraction level for Phase 1.

    **src/storage/migrations.ts:**
    Define a `Migration` interface with `version`, `description`, and `up` (SQL string).

    Create `migrations` array with initial migration (version 1):
    - schema_version table (version INTEGER PRIMARY KEY, applied_at TEXT, description TEXT)
    - relationships table (relationship_id TEXT PK, patient_agent_id TEXT NOT NULL, provider_npi TEXT NOT NULL, status TEXT NOT NULL DEFAULT 'pending', consented_actions TEXT, created_at TEXT, updated_at TEXT) with indexes on patient_agent_id, provider_npi, status
    - appointments table (appointment_id TEXT PK, relationship_id TEXT NOT NULL, provider_npi TEXT NOT NULL, scheduled_at TEXT NOT NULL, duration_minutes INTEGER NOT NULL, status TEXT NOT NULL DEFAULT 'scheduled', notes TEXT, created_at TEXT, updated_at TEXT) with indexes on relationship_id, provider_npi, status, scheduled_at
    - billing_records table (billing_id TEXT PK, relationship_id TEXT NOT NULL, provider_npi TEXT NOT NULL, appointment_id TEXT, cpt_entries TEXT NOT NULL, icd10_codes TEXT NOT NULL, status TEXT NOT NULL DEFAULT 'draft', total_amount REAL, created_at TEXT, updated_at TEXT) with indexes on relationship_id, status
    - termination_records table (termination_id TEXT PK, relationship_id TEXT NOT NULL, provider_npi TEXT NOT NULL, reason TEXT NOT NULL, terminated_at TEXT NOT NULL, audit_entry_sequence INTEGER)
    - cached_chart_entries table (entry_id TEXT PK, relationship_id TEXT NOT NULL, content_hash TEXT NOT NULL, content TEXT NOT NULL, received_at TEXT NOT NULL) with index on relationship_id
    - sync_state table (relationship_id TEXT PK, last_sync_at TEXT NOT NULL, entry_count INTEGER NOT NULL DEFAULT 0)

    Export `runMigrations(db: Database.Database): void` that:
    1. Creates schema_version table if not exists
    2. Reads current max version
    3. Runs pending migrations in a transaction
    4. Records each applied version

    **src/storage/sqlite.ts:**
    Implement `SqliteStorage` class implementing `StorageEngine`:
    - Constructor takes `path: string` (use ':memory:' for tests)
    - Opens better-sqlite3 connection
    - Sets pragmas: `journal_mode = WAL`, `foreign_keys = ON`
    - `initialize()` calls `runMigrations(this.db)`
    - `run()`, `get()`, `all()` wrap db.prepare().run/get/all
    - `transaction()` wraps db.transaction()
    - `close()` calls db.close()

    **src/storage/index.ts:**
    Barrel export: `StorageEngine`, `SqliteStorage`, `RunResult`.

    **src/storage/sqlite.test.ts:**
    Test with in-memory SQLite (`:memory:`):
    - initialize() creates all expected tables (query sqlite_master)
    - run() executes INSERT, returns changes count
    - get() returns single row or undefined
    - all() returns array of rows
    - transaction() commits on success, rolls back on error
    - close() and reopen file-based DB preserves data (use temp file)
    - migrations are idempotent (calling initialize() twice doesn't error)
    - WAL mode is enabled (pragma query confirms)
  </action>
  <verify>
    `pnpm vitest run src/storage/sqlite.test.ts` -- all tests pass.
    Verify in-memory mode works without creating files.
    Verify all tables created by checking sqlite_master.
  </verify>
  <done>
    StorageEngine interface defined. SqliteStorage implements it with better-sqlite3, WAL mode, foreign keys. Migrations create all core tables with indexes. In-memory mode works for tests. All test cases pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD -- Hash-chained JSONL audit logger with integrity verification</name>
  <files>
    src/audit/serialize.ts
    src/audit/logger.ts
    src/audit/verifier.ts
    src/audit/index.ts
    src/audit/audit.test.ts
  </files>
  <action>
    Implement the hash-chained audit log system using TDD.

    **RED phase -- write failing tests first for canonicalize:**

    Create `src/audit/audit.test.ts` with test groups:

    Group 1 - Deterministic serialization:
    - Objects with different key insertion order produce identical canonical JSON
    - Nested objects have keys sorted recursively
    - Arrays maintain element order (not sorted)
    - Handles null, numbers, booleans, strings correctly
    - Empty objects and arrays handled

    Group 2 - Hash chain:
    - First entry has prev_hash of 64 zeros (genesis)
    - Second entry's prev_hash equals first entry's hash
    - Entry hash is SHA-256 of canonical JSON (excluding the hash field itself)
    - Each audit category type can be logged ('registration', 'connection', 'consent', 'api_access', 'sync', 'admin', 'termination')
    - Sequence numbers increment monotonically

    Group 3 - Chain verification:
    - Valid chain passes verification
    - Tampered entry (modified content) fails verification
    - Missing entry (gap in sequence) fails verification
    - Empty log passes verification (trivially valid)
    - Single entry with genesis prev_hash passes

    Run tests -- they MUST fail.
    Commit: `test(01-03): add failing tests for audit chain and canonicalization`

    **GREEN phase -- implement:**

    **src/audit/serialize.ts:**
    Export `canonicalize(value: unknown): string`:
    - null/primitives: `JSON.stringify(value)`
    - Arrays: `[` + elements mapped through canonicalize, joined by `,` + `]`
    - Objects: sort keys with `Object.keys(obj).sort()`, produce `{` + sorted key:value pairs + `}`
    - Recursive for nested structures

    **src/audit/logger.ts:**
    Export `AuditLogger` class:
    - Constructor takes `auditPath: string`
    - On construction: if file exists, read last line to get last hash and sequence; if not, genesis state (prev_hash = '0'.repeat(64), sequence = 0)
    - `append(event: { category: AuditCategory, action: string, actor?: string, details?: Record<string, unknown> }): AuditEntry`
      1. Build entry object: timestamp (ISO), sequence (increment), category, action, actor, details, prev_hash
      2. Canonicalize the entry (WITHOUT hash field)
      3. SHA-256 hash the canonical string -> hex
      4. Add hash to entry
      5. JSON.stringify the full entry (including hash) and append to file with newline
      6. Update lastHash and sequence
      7. Return the entry
    - Handle file creation if doesn't exist
    - Handle crash recovery on startup: if last line is invalid JSON, truncate it and log warning

    **src/audit/verifier.ts:**
    Export `verifyAuditChain(auditPath: string): VerificationResult`:
    - Read file line by line
    - For each line: parse JSON, extract hash field, canonicalize remaining fields, compute SHA-256, compare
    - Verify prev_hash matches previous entry's hash (first entry must have genesis hash)
    - Verify sequences are monotonically increasing
    - Return `{ valid: boolean, entries: number, errors: Array<{ line: number, error: string }> }`

    Export `VerificationResult` type.

    **src/audit/index.ts:**
    Barrel export: `AuditLogger`, `verifyAuditChain`, `canonicalize`, `VerificationResult`.

    Run tests -- they MUST pass.
    Commit: `feat(01-03): implement hash-chained audit logger with verification`

    **REFACTOR phase:**
    Add JSDoc comments to public APIs. Ensure error messages are clear. Tests must still pass.
  </action>
  <verify>
    `pnpm vitest run src/audit/audit.test.ts` -- all tests pass.
    Manual verification: create a logger, append 3 entries, verify chain passes. Modify one entry's content in the file, verify chain fails.
  </verify>
  <done>
    canonicalize produces deterministic JSON with sorted keys. AuditLogger appends hash-chained JSONL entries with SHA-256 linkage. verifyAuditChain validates the entire chain and reports specific errors for tampered or missing entries. All 7 audit event categories supported. All TDD tests pass.
  </done>
</task>

</tasks>

<verification>
- Storage: in-memory SQLite initializes, persists data, closes cleanly
- Storage: all tables and indexes created by migration
- Audit: canonicalize produces identical output for different key orders
- Audit: hash chain links entries via prev_hash -> hash
- Audit: verifyAuditChain detects tampering
- Audit: all 7 event categories can be logged
- All tests pass with `pnpm vitest run`
</verification>

<success_criteria>
- StorageEngine interface with SqliteStorage implementation (WAL mode, foreign keys)
- Embedded migrations create all core tables with indexes
- In-memory SQLite for tests, file-backed for production
- AuditLogger appends hash-chained JSONL with deterministic serialization
- verifyAuditChain validates chain integrity offline
- All tests written TDD-style and passing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
