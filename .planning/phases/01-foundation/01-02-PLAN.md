---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on: [01]
files_modified:
  - src/validators/npi.ts
  - src/validators/npi.test.ts
  - src/config/schema.ts
  - src/config/loader.ts
  - src/config/defaults.ts
  - src/config/index.ts
  - src/config/loader.test.ts
autonomous: true
requirements:
  - FOUN-02
  - FOUN-03
  - FOUN-04
  - FOUN-05
must_haves:
  truths:
    - "A valid 10-digit NPI passes validation; an invalid Luhn check digit is rejected"
    - "A config file is read, validated against TypeBox schema, and returns a typed NeuronConfig"
    - "NEURON_ environment variables override nested config values using double-underscore convention"
    - "Invalid configuration produces field-level error messages and never allows startup"
    - "Missing config file produces a clear error message"
  artifacts:
    - path: "src/validators/npi.ts"
      provides: "NPI validation utility"
      exports: ["isValidNpi"]
    - path: "src/config/loader.ts"
      provides: "Config loading pipeline: read file, apply env overrides, validate"
      exports: ["loadConfig"]
    - path: "src/config/schema.ts"
      provides: "TypeBox config schema with defaults"
      exports: ["NeuronConfigSchema"]
    - path: "src/config/defaults.ts"
      provides: "Default configuration values"
      exports: ["DEFAULT_CONFIG"]
  key_links:
    - from: "src/config/loader.ts"
      to: "src/types/config.ts"
      via: "imports NeuronConfigSchema for validation"
      pattern: "import.*NeuronConfigSchema"
    - from: "src/config/loader.ts"
      to: "src/validators/npi.ts"
      via: "validates organization NPI during config load"
      pattern: "isValidNpi"
---

<objective>
Implement NPI validation (TDD) and the complete configuration loading pipeline.

Purpose: NPI validation is a pure function with well-defined I/O -- ideal for TDD. The config loader is the gateway to startup: it reads the config file, applies environment variable overrides, validates against the TypeBox schema, validates the organization NPI, and either returns a fully typed config or fails with clear errors. This plan delivers two of the five success criteria for Phase 1.

Output: Tested NPI validator and config loader that prevents startup with invalid configuration.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD -- NPI Luhn validation utility</name>
  <files>
    src/validators/npi.ts
    src/validators/npi.test.ts
  </files>
  <action>
    Implement NPI validation using TDD (RED -> GREEN -> REFACTOR).

    **RED phase -- write failing tests first:**

    Create `src/validators/npi.test.ts` with test cases:
    - Valid NPIs pass (use known valid NPIs: "1234567893", "1245319599", "1003000126")
    - Invalid Luhn check digit fails (change last digit of valid NPI)
    - Non-10-digit strings fail ("123456789", "12345678901", "")
    - Non-numeric strings fail ("123456789a", "abcdefghij")
    - Strings with spaces or hyphens fail ("123 456 7893", "123-456-7893")

    Run tests -- they MUST fail (function doesn't exist yet).
    Commit: `test(01-02): add failing tests for NPI Luhn validation`

    **GREEN phase -- implement minimally:**

    Create `src/validators/npi.ts` with `isValidNpi(npi: string): boolean`:
    1. Check format: exactly 10 digits (`/^\d{10}$/`)
    2. Apply CMS Luhn algorithm:
       - Parse digits to number array
       - Starting from rightmost digit (check digit), double every second digit moving left
       - If doubled value > 9, subtract 9 (equivalent to summing digits)
       - Sum all digits
       - Add constant 24 (for 10-position NPI, accounts for "80840" prefix)
       - Add the check digit
       - Valid if total % 10 === 0

    Run tests -- they MUST pass.
    Commit: `feat(01-02): implement NPI Luhn validation`

    **REFACTOR phase (if needed):**
    Clean up, add JSDoc comments. Tests must still pass.
  </action>
  <verify>
    `pnpm vitest run src/validators/npi.test.ts` -- all tests pass.
    Verify known valid NPI "1234567893" passes.
    Verify "1234567890" (invalid check digit) fails.
  </verify>
  <done>
    isValidNpi correctly validates 10-digit NPIs using the CMS Luhn algorithm with constant 24. All test cases pass including edge cases for format and check digit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configuration loading pipeline with env overrides and validation</name>
  <files>
    src/config/schema.ts
    src/config/loader.ts
    src/config/defaults.ts
    src/config/index.ts
    src/config/loader.test.ts
  </files>
  <action>
    Build the complete config loading pipeline: file read -> env override -> validate -> return typed config or throw with clear errors.

    **src/config/defaults.ts:**
    Export `DEFAULT_CONFIG` object with all default values matching the TypeBox schema defaults:
    ```
    server.port: 3000, server.host: '0.0.0.0'
    storage.path: './data/neuron.db'
    audit.path: './data/audit.jsonl', audit.enabled: true
    localNetwork.enabled: false
    heartbeat.intervalMs: 60000
    ```

    **src/config/schema.ts:**
    Re-export the NeuronConfigSchema from `src/types/config.ts` if identical, or create a config-specific schema here if the config file schema differs from the internal type. The config file schema should match what users write in `neuron.config.json`.

    **src/config/loader.ts:**
    Export `loadConfig(configPath: string): NeuronConfig` that:

    1. **Read file:** `fs.readFileSync(configPath, 'utf-8')` -> `JSON.parse()`. If file not found, throw `ConfigError` with message: `Configuration file not found: ${configPath}`. If JSON parse fails, throw `ConfigError` with message: `Invalid JSON in configuration file: ${configPath}`.

    2. **Merge with defaults:** Deep merge user config over DEFAULT_CONFIG so missing fields get defaults.

    3. **Apply env overrides:** Scan `process.env` for keys starting with `NEURON_`. Map `NEURON_SERVER__PORT` -> path `['server', 'port']`. Apply type coercion:
       - Numeric strings (`/^\d+$/`) -> number
       - `"true"` / `"false"` -> boolean
       - Everything else -> string
       Set nested value on merged config.

    4. **Validate with TypeBox:** Use `Value.Check(NeuronConfigSchema, config)`. If invalid, collect errors with `[...Value.Errors(NeuronConfigSchema, config)]` and throw `ConfigError` with formatted message listing each field path and error. Format: `Configuration invalid:\n  - /organization/npi: Expected string matching pattern\n  - /server/port: Expected number`.

    5. **Validate NPI:** Call `isValidNpi(config.organization.npi)`. If invalid, throw `ConfigError`: `Invalid NPI "${npi}": fails Luhn check digit validation`.

    6. **Freeze and return:** `Object.freeze(config)` recursively, return as `NeuronConfig`.

    Export `ConfigError extends Error` class with a `fields` property for programmatic error access.

    **src/config/index.ts:**
    Barrel export: `loadConfig`, `ConfigError`, `DEFAULT_CONFIG`.

    **src/config/loader.test.ts:**
    Test cases (use temp files via `os.tmpdir()`):
    - Valid config file loads and returns typed NeuronConfig
    - Missing fields get defaults (e.g., omit server.port, get 3000)
    - NEURON_SERVER__PORT=8080 overrides server.port to number 8080
    - NEURON_AUDIT__ENABLED=false overrides audit.enabled to boolean false
    - Missing config file throws ConfigError with file path in message
    - Invalid JSON throws ConfigError
    - Missing required field (organization.npi) throws ConfigError listing the field
    - Invalid NPI (bad Luhn) throws ConfigError with NPI-specific message
    - Config object is frozen (attempting to modify throws in strict mode)
    - Single underscore maps to top-level keys, double underscore to nested paths

    Clean up env vars in afterEach to avoid test pollution.
  </action>
  <verify>
    `pnpm vitest run src/config/loader.test.ts` -- all tests pass.
    Verify error messages include specific field paths for validation failures.
    Verify env var overrides correctly coerce types (port string -> number).
  </verify>
  <done>
    loadConfig reads neuron.config.json, merges defaults, applies NEURON_ env overrides with type coercion, validates against TypeBox schema, validates NPI via Luhn, and returns a frozen NeuronConfig. Invalid config produces clear field-level error messages and throws ConfigError. All test cases pass.
  </done>
</task>

</tasks>

<verification>
- NPI validation: "1234567893" passes, "1234567890" fails, non-10-digit rejected
- Config loading: valid file returns typed config, invalid file throws with field-level errors
- Env overrides: NEURON_SERVER__PORT=8080 sets server.port to number 8080
- Missing config: clear error message with file path
- All tests pass with `pnpm vitest run`
</verification>

<success_criteria>
- isValidNpi implements CMS Luhn with constant 24, all edge cases tested
- loadConfig pipeline: read -> merge defaults -> env override -> validate -> freeze
- ConfigError provides field-level error messages for all validation failures
- Environment variable type coercion handles numbers, booleans, strings
- All tests pass, NPI tests written TDD-style (red then green)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
