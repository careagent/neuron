---
phase: 02-axon-registration
plan: 03
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/ipc/protocol.ts
  - src/ipc/server.ts
  - src/ipc/client.ts
  - src/ipc/index.ts
  - src/ipc/ipc.test.ts
autonomous: true
requirements: [NREG-04]

must_haves:
  truths:
    - "IPC server listens on a Unix domain socket and handles JSON commands"
    - "IPC client connects to the socket, sends a command, and receives a response"
    - "IPC client times out with a clear error when the server is not running"
    - "Stale socket files are cleaned up on server startup"
  artifacts:
    - path: "src/ipc/protocol.ts"
      provides: "TypeBox schemas for IPC command/response protocol"
      exports: ["IpcCommandSchema", "IpcCommand", "IpcResponseSchema", "IpcResponse"]
    - path: "src/ipc/server.ts"
      provides: "Unix domain socket server for CLI-to-daemon communication"
      exports: ["startIpcServer", "IpcHandler"]
    - path: "src/ipc/client.ts"
      provides: "Unix domain socket client for CLI commands"
      exports: ["sendIpcCommand"]
    - path: "src/ipc/ipc.test.ts"
      provides: "Unit tests for IPC server and client"
  key_links:
    - from: "src/ipc/server.ts"
      to: "node:net"
      via: "net.createServer for Unix socket"
      pattern: "net\\.createServer"
    - from: "src/ipc/client.ts"
      to: "node:net"
      via: "net.createConnection for socket client"
      pattern: "net\\.createConnection"
    - from: "src/ipc/protocol.ts"
      to: "@sinclair/typebox"
      via: "TypeBox schemas for message validation"
      pattern: "Type\\.Object"
---

<objective>
Build the IPC communication layer between CLI commands and the running Neuron server process.

Purpose: The user's locked decision requires provider add/remove to take effect immediately (hot) by contacting the running Neuron process. Unix domain socket IPC provides bidirectional, low-latency communication without TCP port allocation.

Output: IPC protocol schemas, socket server (for embedding in `neuron start`), and socket client (for CLI commands).
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-axon-registration/02-RESEARCH.md

@src/types/config.ts
@src/cli/output.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: IPC protocol schemas and Unix socket server</name>
  <files>
    src/ipc/protocol.ts
    src/ipc/server.ts
  </files>
  <action>
1. Create `src/ipc/protocol.ts`:
   - Import `Type` and `Static` from `@sinclair/typebox`
   - Define `IpcCommandSchema` as `Type.Union([...])` with these command types:
     - `Type.Object({ type: Type.Literal('provider.add'), npi: Type.String() })`
     - `Type.Object({ type: Type.Literal('provider.remove'), npi: Type.String() })`
     - `Type.Object({ type: Type.Literal('provider.list') })`
     - `Type.Object({ type: Type.Literal('status') })`
   - Export `type IpcCommand = Static<typeof IpcCommandSchema>`
   - Define `IpcResponseSchema` as `Type.Object({ ok: Type.Boolean(), data: Type.Optional(Type.Unknown()), error: Type.Optional(Type.String()) })`
   - Export `type IpcResponse = Static<typeof IpcResponseSchema>`

2. Create `src/ipc/server.ts`:
   - Import `net` from `node:net`, `unlinkSync` from `node:fs`
   - Export type `IpcHandler = (command: IpcCommand) => Promise<IpcResponse>`
   - Export function `startIpcServer(socketPath: string, handler: IpcHandler): net.Server`:
     - Clean up stale socket file first: `try { unlinkSync(socketPath) } catch {}` (per research pitfall 1: stale socket on crash)
     - Create `net.createServer` with connection handler:
       - Maintain a string buffer per connection
       - On `data` event: append chunk to buffer, split by newline (NDJSON protocol)
       - For each complete line: parse JSON as IpcCommand, call handler, write JSON response + newline back to socket
       - On parse error: write `{ ok: false, error: 'invalid json' }` response
       - On handler error: write `{ ok: false, error: String(err) }` response
       - On socket `error` event: ignore (client disconnected)
     - Call `server.listen(socketPath)`
     - Return the server instance (caller manages lifecycle)
   - Export function `getSocketPath(storagePath: string): string`:
     - Derive socket path from config storage.path: `path.join(path.dirname(storagePath), 'neuron.sock')`
     - This ties socket location to data directory (per research recommendation: avoid hardcoded /tmp paths, prevent multi-user collisions)
  </action>
  <verify>
    `pnpm build` compiles cleanly with no type errors on new IPC files.
  </verify>
  <done>
    - IPC protocol defines 4 command types (provider.add, provider.remove, provider.list, status) with TypeBox schemas
    - IPC server listens on Unix domain socket, handles NDJSON protocol, routes commands to handler
    - Stale socket files cleaned up on server start (prevents EADDRINUSE after crash)
    - Socket path derived from storage.path directory (no hardcoded paths)
  </done>
</task>

<task type="auto">
  <name>Task 2: IPC client and unit tests</name>
  <files>
    src/ipc/client.ts
    src/ipc/index.ts
    src/ipc/ipc.test.ts
  </files>
  <action>
1. Create `src/ipc/client.ts`:
   - Import `net` from `node:net`
   - Export function `sendIpcCommand<T = unknown>(socketPath: string, command: IpcCommand): Promise<IpcResponse & { data?: T }>`:
     - Create `net.createConnection({ path: socketPath })` with connection callback
     - On connect: write `JSON.stringify(command) + '\n'`
     - Maintain buffer, on `data` event: append to buffer, split by newline
     - On first complete response line: parse JSON, resolve promise, destroy socket
     - On socket `error` event:
       - If error code is `ENOENT` (socket file doesn't exist): reject with message "Neuron is not running (socket not found)"
       - If error code is `ECONNREFUSED`: reject with message "Neuron is not running (connection refused)"
       - Otherwise: reject with the error
     - Set `socket.setTimeout(5000, ...)`: on timeout, reject with "IPC command timed out â€” is the Neuron running?", destroy socket (per research pitfall 2: CLI hangs when server not running)

2. Create `src/ipc/index.ts`:
   - Barrel export: `startIpcServer`, `sendIpcCommand`, `getSocketPath`, `IpcHandler`, all protocol types and schemas

3. Create `src/ipc/ipc.test.ts`:
   - Test IPC server + client round-trip:
     - Start IPC server on a temp socket path (use `os.tmpdir()` + random suffix)
     - Register a simple handler that echoes the command type back
     - Use `sendIpcCommand` to send a `{ type: 'status' }` command
     - Verify response `{ ok: true, data: ... }`
     - Clean up: close server, remove socket file
   - Test client timeout when no server:
     - Use a socket path that doesn't exist
     - Verify `sendIpcCommand` rejects with "not running" message
   - Test server handles invalid JSON:
     - Connect raw socket, send garbage data
     - Verify server responds with `{ ok: false, error: 'invalid json' }`
   - Test multiple sequential commands on same server:
     - Send provider.add, then provider.list
     - Verify both get correct responses
   - Test `getSocketPath` derives path from storage path:
     - `getSocketPath('./data/neuron.db')` should return `'data/neuron.sock'` (relative to storage dir)
   - Use `afterEach` to clean up server and socket file
  </action>
  <verify>
    `pnpm test` passes all tests including new IPC tests. `pnpm build` compiles cleanly.
  </verify>
  <done>
    - IPC client sends commands and receives responses over Unix domain socket
    - Client handles error cases: server not running (ENOENT/ECONNREFUSED), timeout (5s)
    - All IPC components exported via barrel
    - Tests verify round-trip communication, error handling, and socket path derivation
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` passes all tests including IPC tests
2. `pnpm build` compiles with no type errors
3. IPC round-trip test confirms command/response flow over Unix socket
4. Client error handling tests confirm graceful behavior when server is not running
5. NDJSON protocol handles multiple commands correctly
</verification>

<success_criteria>
- IPC server starts on Unix socket, handles NDJSON commands, delegates to handler, returns responses
- IPC client connects, sends command, receives response, handles timeout and connection errors
- Socket path derived from config (not hardcoded)
- Stale socket cleanup prevents EADDRINUSE after crash
- All tests pass with >80% coverage
</success_criteria>

<output>
After completion, create `.planning/phases/02-axon-registration/02-03-SUMMARY.md`
</output>
