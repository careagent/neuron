---
phase: 02-axon-registration
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/registration/axon-client.ts
  - src/registration/state.ts
  - src/registration/heartbeat.ts
  - src/registration/service.ts
  - src/registration/index.ts
  - src/registration/registration.test.ts
autonomous: true
requirements: [NREG-01, NREG-02, NREG-03, NREG-06]

must_haves:
  truths:
    - "AxonClient can register a neuron with the Axon registry and receive a registration_id and bearer_token"
    - "AxonClient can register and remove providers through the neuron's registration"
    - "HeartbeatManager sends periodic endpoint updates and enters exponential backoff on failure"
    - "HeartbeatManager resets to healthy interval after Axon recovers"
    - "Registration state persists in SQLite and survives process restart"
    - "When Axon is unreachable, the Neuron continues operating in degraded mode"
    - "A machine-readable neuron.health.json file is written on every heartbeat status change for external monitoring"
  artifacts:
    - path: "src/registration/axon-client.ts"
      provides: "Thin HTTP wrapper for Axon registry API"
      exports: ["AxonClient", "AxonError"]
    - path: "src/registration/state.ts"
      provides: "SQLite read/write for registration state"
      exports: ["RegistrationStateStore"]
    - path: "src/registration/heartbeat.ts"
      provides: "Heartbeat loop with exponential backoff and health metric file writer"
      exports: ["HeartbeatManager", "HEARTBEAT_INTERVAL_MS", "writeHealthFile"]
    - path: "src/registration/service.ts"
      provides: "Orchestrator coordinating client, state, and heartbeat"
      exports: ["AxonRegistrationService"]
    - path: "src/registration/registration.test.ts"
      provides: "Unit tests for all registration components"
  key_links:
    - from: "src/registration/axon-client.ts"
      to: "Axon registry HTTP API"
      via: "node:fetch calls to /v1/neurons endpoints"
      pattern: "fetch.*registryUrl"
    - from: "src/registration/state.ts"
      to: "src/storage/interface.ts"
      via: "StorageEngine SQL operations"
      pattern: "storage\\.(run|get|all)"
    - from: "src/registration/heartbeat.ts"
      to: "src/registration/axon-client.ts"
      via: "calls client.updateEndpoint on each beat"
      pattern: "client\\.updateEndpoint"
    - from: "src/registration/service.ts"
      to: "src/registration/axon-client.ts"
      via: "delegates HTTP calls"
      pattern: "this\\.client\\."
---

<objective>
Build the core registration engine: HTTP client for Axon, persistent state store, heartbeat with backoff, and orchestrating service.

Purpose: This is the brain of Phase 2. It handles all communication with Axon, persists registration state across restarts, and maintains reachable status through heartbeats with graceful degradation.

Output: Four modules (`axon-client`, `state`, `heartbeat`, `service`) with comprehensive unit tests.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-axon-registration/02-RESEARCH.md
@.planning/phases/02-axon-registration/02-01-SUMMARY.md

@src/types/registration.ts
@src/types/config.ts
@src/storage/interface.ts
@src/audit/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: AxonClient HTTP wrapper and RegistrationStateStore</name>
  <files>
    src/registration/axon-client.ts
    src/registration/state.ts
  </files>
  <action>
1. Install MSW for unit test HTTP interception: `pnpm add -D msw`

2. Create `src/registration/axon-client.ts`:
   - Export `AxonError` class extending Error with `statusCode: number` property
   - Export `AxonClient` class:
     - Constructor: `(registryUrl: string, bearerToken?: string)`
     - `async registerNeuron(payload: { organization_npi: string, organization_name: string, organization_type: string, neuron_endpoint_url: string }): Promise<{ registration_id: string, bearer_token: string, status: string }>`
       - POST to `${registryUrl}/v1/neurons`
       - Headers: Content-Type application/json, Authorization Bearer if bearerToken set
       - On non-ok: throw AxonError with status code
       - Return parsed JSON response
     - `async updateEndpoint(registrationId: string, payload: { neuron_endpoint_url: string }): Promise<void>`
       - PUT to `${registryUrl}/v1/neurons/${registrationId}/endpoint`
       - Headers: Content-Type, Authorization Bearer
       - On non-ok: throw AxonError
     - `async registerProvider(registrationId: string, payload: { provider_npi: string }): Promise<{ provider_id: string, status: string }>`
       - POST to `${registryUrl}/v1/neurons/${registrationId}/providers`
       - On non-ok: throw AxonError
     - `async removeProvider(registrationId: string, providerNpi: string): Promise<void>`
       - DELETE to `${registryUrl}/v1/neurons/${registrationId}/providers/${providerNpi}`
       - On non-ok: throw AxonError
   - `setBearerToken(token: string)` method to update token after initial registration
   - Use `node:fetch` (built-in, project requires Node >=20.19.0)
   - Do NOT retry on 4xx errors (per research anti-pattern). Only network errors and 5xx warrant retry (handled by heartbeat layer, not client).

3. Create `src/registration/state.ts`:
   - Export `RegistrationStateStore` class:
     - Constructor: `(storage: StorageEngine)` — receives the StorageEngine interface from Phase 1
     - `load(): NeuronRegistrationState | null` — read from `neuron_registration` table + join `provider_registrations`, return null if no row
     - `save(state: Omit<NeuronRegistrationState, 'providers'>): void` — INSERT OR REPLACE into `neuron_registration` (single row, id=1)
     - `updateHeartbeat(timestamp: string): void` — UPDATE `neuron_registration` SET `last_heartbeat_at` and `last_axon_response_at`
     - `updateStatus(status: string): void` — UPDATE `neuron_registration` SET `status`
     - `saveProvider(provider: ProviderRegistration): void` — INSERT OR REPLACE into `provider_registrations`
     - `removeProvider(providerNpi: string): void` — DELETE from `provider_registrations`
     - `listProviders(): ProviderRegistration[]` — SELECT all from `provider_registrations`
   - Import types from `../types/registration.js`
   - Import `StorageEngine` from `../storage/interface.js`
   - Use parameterized queries (storage.run/get/all with params array)

Note: Bearer token is stored in `neuron_registration.axon_bearer_token`. It is sensitive — per research pitfall 7, the service layer must NEVER log or audit this value.
  </action>
  <verify>
    `pnpm build` compiles with no errors. Verify MSW installed: `pnpm ls msw`.
  </verify>
  <done>
    - AxonClient wraps all 4 Axon API operations (registerNeuron, updateEndpoint, registerProvider, removeProvider) with typed error handling
    - RegistrationStateStore provides full CRUD for neuron_registration and provider_registrations via StorageEngine
    - Both modules have zero runtime dependencies beyond Node.js built-ins and project internals
  </done>
</task>

<task type="auto">
  <name>Task 2: HeartbeatManager, AxonRegistrationService, and unit tests</name>
  <files>
    src/registration/heartbeat.ts
    src/registration/service.ts
    src/registration/index.ts
    src/registration/registration.test.ts
  </files>
  <action>
1. Create `src/registration/heartbeat.ts`:
   - Define and export `const HEARTBEAT_INTERVAL_MS = 60_000` at module level (per locked decision: 60-second heartbeat interval, fixed, not configurable)
   - Export `HeartbeatManager` class:
     - Constructor: `(client: AxonClient, stateStore: RegistrationStateStore, backoffCeilingMs: number, onStatusChange?: (status: 'healthy' | 'degraded') => void)`
     - Note: the heartbeat interval is NOT a constructor parameter — it uses the module constant `HEARTBEAT_INTERVAL_MS` directly. This enforces the locked decision that it is fixed, not configurable.
     - `start(): void` — set `isRunning = true`, schedule first beat at `HEARTBEAT_INTERVAL_MS`
     - `stop(): void` — set `isRunning = false`, clear any pending timeout
     - `getStatus(): 'healthy' | 'degraded'` — return current status based on `attempt` counter (0 = healthy, >0 = degraded)
     - Private `scheduleNext(delayMs: number)`: use `setTimeout` (not `setInterval`) for dynamic delay adjustment
     - Private `async beat()`:
       1. If not running, return
       2. Load registration state from stateStore
       3. If no state or status !== 'registered', schedule next at `HEARTBEAT_INTERVAL_MS` and return
       4. Try: call `client.updateEndpoint(registrationId, { neuron_endpoint_url })`, reset `attempt = 0`, update stateStore heartbeat timestamp, call `onStatusChange?.('healthy')` if transitioning from degraded, schedule next at `HEARTBEAT_INTERVAL_MS`
       5. Catch: increment `attempt`, calculate backoff: `Math.min(backoffCeilingMs, Math.pow(2, attempt) * 5000 * Math.random())` (full jitter per research recommendation), call `onStatusChange?.('degraded')` if first failure, schedule next at backoffMs
   - Per locked decision: 60-second interval via `HEARTBEAT_INTERVAL_MS` constant (fixed, not configurable). Backoff ceiling configurable (default 5 min from config).
   - Per locked decision: Auto re-register when Axon comes back — if `updateEndpoint` returns 404 (registration lost), call `onRegistrationLost` callback so the service can re-register.

   **Health metric file (per locked decision: "exposed health metric for monitoring systems"):**
   - Export function `writeHealthFile(dataDir: string, status: 'healthy' | 'degraded', lastHeartbeat?: string): void`
     - Writes `neuron.health.json` to `dataDir` (same directory as the SQLite DB)
     - File contents: `{ "status": "healthy"|"degraded", "last_heartbeat_at": "<ISO string>"|null, "updated_at": "<ISO string>" }`
     - Use `writeFileSync` (atomic enough for a status file, non-blocking not needed for a small JSON write)
     - This file is machine-readable and can be polled by external monitoring systems (e.g., Prometheus node exporter, custom health checks)
   - The `onStatusChange` callback in HeartbeatManager is the trigger — AxonRegistrationService wires it to call `writeHealthFile` on every status transition
   - Also call `writeHealthFile` after each successful heartbeat (to update `last_heartbeat_at` even when status doesn't change)

2. Create `src/registration/service.ts`:
   - Export `AxonRegistrationService` class:
     - Constructor: `(config: NeuronConfig, storage: StorageEngine, auditLogger?: AuditLogger)`
     - Private fields: `client: AxonClient`, `stateStore: RegistrationStateStore`, `heartbeat: HeartbeatManager`
     - `async start(): Promise<void>`:
       1. Create `AxonClient` with `config.axon.registryUrl`
       2. Create `RegistrationStateStore` with storage
       3. Load existing state from store
       4. If status === 'registered' and registration_id exists: skip registration, set bearer token on client, proceed to heartbeat (per research pitfall 6: idempotency on restart)
       5. If status !== 'registered': call `client.registerNeuron(...)` with org details from config, save state with registration_id and bearer_token, audit log `action: 'registration.neuron_registered'` (do NOT include bearer_token in audit details per pitfall 7)
       6. Also re-register any existing providers from state (they survive restart per NREG-05)
       7. Create HeartbeatManager with `config.axon.backoffCeilingMs` (interval is the fixed `HEARTBEAT_INTERVAL_MS` constant from heartbeat.ts, not a config value). Pass `onStatusChange` callback that calls `writeHealthFile(dataDir, status, lastHeartbeat)` to write `neuron.health.json` (per locked decision: exposed health metric for monitoring systems). Start heartbeat.
     - `async stop(): Promise<void>` — stop heartbeat
     - `async addProvider(npi: string): Promise<void>` — call `client.registerProvider(...)`, save to stateStore, audit log `action: 'registration.provider_added'`
     - `async removeProvider(npi: string): Promise<void>` — call `client.removeProvider(...)`, remove from stateStore, audit log `action: 'registration.provider_removed'`
     - `listProviders(): ProviderRegistration[]` — delegate to stateStore.listProviders()
     - `getStatus(): { neuron: NeuronRegistrationState | null, heartbeat: 'healthy' | 'degraded' }` — return current state and heartbeat status
   - Handle network errors gracefully in start(): if Axon unreachable on first start, log warning and enter degraded mode (do not crash — per NREG-06)

3. Create `src/registration/index.ts`:
   - Barrel export: `AxonRegistrationService`, `AxonClient`, `AxonError`, `RegistrationStateStore`, `HeartbeatManager`, `HEARTBEAT_INTERVAL_MS`, `writeHealthFile`

4. Create `src/registration/registration.test.ts`:
   - Use MSW `setupServer` for HTTP interception in AxonClient tests:
     - registerNeuron returns 201 with registration_id and bearer_token
     - updateEndpoint returns 200
     - registerProvider returns 201 with provider_id
     - removeProvider returns 204
     - Error case: non-ok response throws AxonError with correct status code
   - Use in-memory SQLite (`:memory:`) for RegistrationStateStore tests:
     - save and load round-trip
     - updateHeartbeat updates timestamps
     - saveProvider and listProviders
     - removeProvider
     - load returns null when no registration exists
   - HeartbeatManager tests:
     - Calls updateEndpoint at HEARTBEAT_INTERVAL_MS (60s) intervals (use vi.useFakeTimers)
     - Enters backoff on failure (verify delay increases)
     - Resets attempt on success after failure
     - Stops cleanly
   - AxonRegistrationService tests:
     - start() registers with Axon on first boot
     - start() skips registration on restart if already registered (idempotency)
     - addProvider registers with Axon and persists
     - removeProvider unregisters and removes from state
   - writeHealthFile tests:
     - Writes neuron.health.json with correct structure (status, last_heartbeat_at, updated_at)
     - File is valid JSON parseable by external tools
   - Import `SqliteStorage` from storage module for in-memory DB setup, call `storage.initialize()` to run migrations before each test
  </action>
  <verify>
    `pnpm test` passes all tests (existing Phase 1 tests + new registration tests). `pnpm build` compiles cleanly.
  </verify>
  <done>
    - HeartbeatManager maintains reachable status with 60s interval (via HEARTBEAT_INTERVAL_MS constant), enters exponential backoff (base 5s, full jitter, configurable ceiling) on failure, auto-recovers
    - AxonRegistrationService orchestrates registration lifecycle: initial registration, restart idempotency, provider management, graceful degradation
    - `writeHealthFile` writes `neuron.health.json` to data directory on every heartbeat status change (machine-readable health metric for monitoring systems per locked decision)
    - All registration components have unit tests with MSW HTTP mocking and in-memory SQLite
    - Bearer token is never logged or included in audit entries
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` passes all tests including new registration tests
2. `pnpm build` compiles with no type errors
3. AxonClient unit tests verify all 4 HTTP operations succeed and error handling works
4. RegistrationStateStore tests verify SQLite persistence round-trips
5. HeartbeatManager tests verify interval scheduling, backoff escalation, and recovery
6. AxonRegistrationService tests verify startup registration, restart idempotency, and provider management
</verification>

<success_criteria>
- AxonClient can make all 4 API calls to Axon (register neuron, heartbeat, register/remove provider)
- Registration state persists in SQLite and loads correctly on restart
- HeartbeatManager schedules heartbeats at 60s intervals and enters exponential backoff on Axon failure
- AxonRegistrationService handles first boot vs restart correctly (no duplicate registrations)
- Graceful degradation: Axon unreachable does not crash the Neuron
- All tests pass with >80% coverage on new files
</success_criteria>

<output>
After completion, create `.planning/phases/02-axon-registration/02-02-SUMMARY.md`
</output>
