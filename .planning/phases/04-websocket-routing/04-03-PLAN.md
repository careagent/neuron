---
phase: 04-websocket-routing
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/cli/commands/start.ts
  - src/routing/routing.test.ts
autonomous: true
requirements: [ROUT-01, ROUT-02, ROUT-05, ROUT-06]

must_haves:
  truths:
    - "neuron start initializes NeuronProtocolServer and listens on configured port"
    - "neuron start shutdown pipeline stops the WebSocket server before IPC and storage"
    - "A full handshake flow works end-to-end through the real server: connect -> auth -> challenge -> response -> complete -> close"
    - "Auth timeout test confirms connection is closed after authTimeoutMs with AUTH_TIMEOUT error"
    - "Safety ceiling test confirms queued connections are processed when slots open"
    - "Audit events are emitted for handshake_started, handshake_completed, and handshake_failed"
  artifacts:
    - path: "src/cli/commands/start.ts"
      provides: "NeuronProtocolServer wired into neuron start lifecycle"
      contains: "NeuronProtocolServer"
    - path: "src/routing/routing.test.ts"
      provides: "Integration tests for WebSocket routing"
      min_lines: 100
  key_links:
    - from: "src/cli/commands/start.ts"
      to: "src/routing/server.ts"
      via: "instantiate and start NeuronProtocolServer in start command"
      pattern: "NeuronProtocolServer"
    - from: "src/routing/routing.test.ts"
      to: "src/routing/server.ts"
      via: "tests create NeuronProtocolServer, connect with ws client"
      pattern: "NeuronProtocolServer"
    - from: "src/cli/commands/start.ts"
      to: "src/audit/logger.ts"
      via: "audit logger passed to NeuronProtocolServer for connection events"
      pattern: "auditLogger"
---

<objective>
Wire NeuronProtocolServer into the CLI start command and add comprehensive integration tests.

Purpose: Complete the Phase 4 implementation by connecting the WebSocket server to the Neuron's lifecycle (startup and graceful shutdown) and proving correctness through integration tests using a real WebSocket client.

Output: Enhanced start command with WebSocket server lifecycle, and routing integration tests covering all success and failure paths.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-websocket-routing/04-CONTEXT.md
@.planning/phases/04-websocket-routing/04-RESEARCH.md
@.planning/phases/04-websocket-routing/04-01-SUMMARY.md
@.planning/phases/04-websocket-routing/04-02-SUMMARY.md
@src/cli/commands/start.ts
@src/routing/server.ts
@src/routing/handler.ts
@src/routing/session.ts
@src/routing/types.ts
@src/routing/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire NeuronProtocolServer into start command with audit events</name>
  <files>
    src/cli/commands/start.ts
  </files>
  <action>
Modify `src/cli/commands/start.ts` to instantiate and manage NeuronProtocolServer alongside the existing registration and IPC services.

**Changes to the start command action:**

1. **Import NeuronProtocolServer** from `../../routing/index.js`.

2. **After IPC server starts (step 5), before Axon registration (step 6):**
   - Instantiate `NeuronProtocolServer`:
     ```typescript
     const protocolServer = new NeuronProtocolServer(
       config,
       handshakeHandler,
       relationshipStore,
       registrationService,
       auditLogger,
     );
     ```
   - Note: `handshakeHandler` needs to be created. Instantiate a `ConsentHandshakeHandler` using `relationshipStore` and `config.organization.npi`:
     ```typescript
     const handshakeHandler = new ConsentHandshakeHandler(
       relationshipStore,
       config.organization.npi,
       auditLogger,
     );
     ```
   - Start the protocol server:
     ```typescript
     await protocolServer.start(config.server.port);
     output.info(`WebSocket server listening on port ${config.server.port} at ${config.websocket.path}`);
     ```

3. **In the shutdown handler (step 9):**
   - Add `protocolServer.stop()` as the FIRST shutdown step (before registration service, IPC, and storage):
     ```typescript
     const shutdown = async () => {
       clearInterval(keepAlive);

       // Stop WebSocket server first (closes all active handshake connections)
       try {
         await protocolServer.stop();
       } catch {
         // Ignore stop errors during shutdown
       }

       // Stop registration service (stops heartbeat)
       try {
         await registrationService.stop();
       } catch {
         // Ignore stop errors during shutdown
       }

       // ... rest of shutdown unchanged
     };
     ```
   WebSocket server stops first because it may reference registration service for provider lookups. Registration must still be available during WebSocket shutdown.

4. **Import ConsentHandshakeHandler** from `../../relationships/index.js` (already partially imported for TerminationHandler).

5. **Audit events:** The NeuronProtocolServer and handler already emit audit events via the injected auditLogger. The start command just needs to pass the auditLogger through. The handler should emit:
   - `connection.handshake_started` (category: 'connection', action: 'connection.handshake_started') when a patient sends the auth message
   - `connection.handshake_completed` when handshake succeeds (includes relationship_id, patient_agent_id)
   - `connection.handshake_failed` when handshake fails (includes error code)
   - `connection.timeout` when auth timeout fires

   These are emitted by the connection handler (Plan 02), not by the start command. The start command's role is to wire the auditLogger dependency through.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run` -- all existing tests pass. Check that start.ts imports NeuronProtocolServer and ConsentHandshakeHandler, and that shutdown calls protocolServer.stop().
  </verify>
  <done>
    neuron start creates and starts NeuronProtocolServer on server.port. Shutdown pipeline stops WebSocket server before registration service and IPC. ConsentHandshakeHandler instantiated and injected. AuditLogger passed through for connection events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive WebSocket routing integration tests</name>
  <files>
    src/routing/routing.test.ts
  </files>
  <action>
Create `src/routing/routing.test.ts` with integration tests that exercise the full WebSocket handshake flow using real WebSocket connections.

**Test setup (beforeEach/afterEach):**
- Create in-memory SQLite storage (or temp file-backed for test), run migrations
- Create AuditLogger with temp file path
- Create RelationshipStore, ConsentHandshakeHandler, mock RegistrationService (or minimal stub)
- Create NeuronProtocolServer with all dependencies, config with small timeouts for test speed (authTimeoutMs: 500, queueTimeoutMs: 1000, maxConcurrentHandshakes: 2)
- Start server on port 0 (OS-assigned ephemeral port)
- Read assigned port from server
- In afterEach: stop server, clean up temp files

**Ed25519 test key setup:**
- Generate Ed25519 keypair using `crypto.generateKeyPairSync('ed25519')` for test
- Create valid consent token: JSON payload with patient_agent_id, provider_npi, consented_actions, exp (future), iat. Sign with private key.
- Helper to create consent token with configurable claims and expiry

**Test cases:**

1. **Successful full handshake flow (new relationship)**
   - Connect to `ws://localhost:{port}/ws/handshake`
   - Send `handshake.auth` with valid consent token, patient_agent_id, patient_public_key, patient_endpoint
   - Receive `handshake.challenge` with nonce, provider_npi, organization_npi
   - Sign nonce with Ed25519 private key
   - Send `handshake.challenge_response` with signed_nonce
   - Receive `handshake.complete` with relationship_id, provider_endpoint, status: 'new'
   - WebSocket closes with code 1000
   - Verify relationship exists in store

2. **Existing relationship returns existing ID**
   - Pre-create an active relationship in the store for the same patient_agent_id and provider_npi
   - Connect and send handshake.auth with matching consent token
   - Receive handshake.complete with status: 'existing' and the pre-existing relationship_id
   - WebSocket closes with code 1000

3. **Auth timeout**
   - Connect but do NOT send any message
   - After authTimeoutMs (500ms in test config), receive `handshake.error` with code `AUTH_TIMEOUT`
   - WebSocket closes

4. **Invalid JSON message**
   - Connect and send `"not json {{{"`
   - Receive `handshake.error` with code `INVALID_MESSAGE`
   - WebSocket closes

5. **Binary frame rejected**
   - Connect and send a Buffer (binary frame)
   - Receive `handshake.error` with code `INVALID_MESSAGE`
   - WebSocket closes

6. **Invalid consent token signature**
   - Connect and send `handshake.auth` with a tampered/wrong-key signature
   - Receive challenge (challenge-response will fail since we need to verify at challenge response)
   - Send challenge response
   - Receive `handshake.error` with code `CONSENT_FAILED`
   - WebSocket closes

7. **Expired consent token**
   - Create consent token with `exp` in the past
   - Follow handshake flow through challenge response
   - Receive `handshake.error` with code `CONSENT_FAILED`

8. **Safety ceiling queuing**
   - Set maxConcurrentHandshakes to 2
   - Open 2 connections (fill ceiling)
   - Open 3rd connection
   - Complete one of the first 2 handshakes (frees a slot)
   - 3rd connection should now proceed (receives auth timeout or can send auth)
   - Verify 3rd connection was not immediately rejected

9. **Graceful shutdown closes connections**
   - Open a connection
   - Call server.stop()
   - Verify connection receives close code 1001

10. **Connection to wrong path rejected**
    - Try to connect to `ws://localhost:{port}/ws/wrong`
    - Connection should fail (socket destroyed)

11. **activeSessions returns current sessions**
    - Connect, send auth, verify activeSessions() returns 1 session with status 'authenticating' or 'challenged'
    - After handshake completes, activeSessions() returns 0 (session removed on close)

**Testing approach:**
- Use `ws` library's `WebSocket` class as the client (it's already installed from Plan 02)
- Use Promises for async WebSocket events (open, message, close)
- Helper function: `connectAndWaitOpen(port)` returns connected WebSocket
- Helper function: `receiveMessage(ws)` returns Promise<parsed JSON>
- Helper function: `waitForClose(ws)` returns Promise<{code, reason}>
- Keep timeouts short in test config to make tests fast
  </action>
  <verify>
    Run `npx vitest run src/routing/routing.test.ts` -- all new tests pass. Run `npx vitest run` -- all project tests pass (140 existing + new routing tests).
  </verify>
  <done>
    At least 10 integration tests covering: full handshake flow (new + existing relationship), auth timeout, invalid message, binary frame rejection, consent verification failures, safety ceiling queuing, graceful shutdown, wrong path rejection, and activeSessions tracking. All tests use real WebSocket connections to a real NeuronProtocolServer instance on an ephemeral port.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npx vitest run` -- ALL tests pass (140+ existing + new routing tests)
3. `src/cli/commands/start.ts` imports and starts NeuronProtocolServer
4. Shutdown pipeline: protocolServer.stop() -> registrationService.stop() -> ipcServer.close() -> storage.close()
5. routing.test.ts has at least 10 test cases covering success and failure paths
6. Tests use ephemeral ports (port 0) to avoid conflicts
</verification>

<success_criteria>
- neuron start creates NeuronProtocolServer, starts on server.port, logs ready message
- neuron shutdown stops WebSocket server first, then other services
- All handshake flow tests pass end-to-end with real WebSocket connections
- Auth timeout, binary rejection, invalid message, and consent failures are tested
- Safety ceiling queuing is tested (connections queued, not rejected)
- Graceful shutdown closes active connections with 1001
- activeSessions() returns correct state during and after handshakes
- Zero regressions across all project tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-websocket-routing/04-03-SUMMARY.md`
</output>
