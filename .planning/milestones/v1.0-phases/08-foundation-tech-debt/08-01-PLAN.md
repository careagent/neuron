---
phase: 08-foundation-tech-debt
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ipc/protocol.ts
  - src/cli/commands/stop.ts
  - src/cli/commands/start.ts
  - src/api/router.ts
autonomous: true
requirements: [FOUN-06, AUDT-02]
must_haves:
  truths:
    - "`neuron stop` sends IPC shutdown command and running Neuron exits cleanly"
    - "API requests produce `api_access` audit events (api_request, auth_failure, rate_limited)"
    - "All 6 non-deferred audit categories have production producers"
  artifacts:
    - path: "src/ipc/protocol.ts"
      provides: "shutdown command type in IpcCommandSchema"
      contains: "Type.Literal('shutdown')"
    - path: "src/cli/commands/stop.ts"
      provides: "IPC-based stop command"
      contains: "sendIpcCommand"
    - path: "src/api/router.ts"
      provides: "api_access audit events"
      contains: "category: 'api_access'"
  key_links:
    - from: "src/cli/commands/stop.ts"
      to: "src/ipc/client.ts"
      via: "sendIpcCommand with shutdown type"
      pattern: "sendIpcCommand.*shutdown"
    - from: "src/cli/commands/start.ts"
      to: "shutdown function"
      via: "IPC handler case 'shutdown' triggers shutdown()"
      pattern: "case 'shutdown'"
    - from: "src/api/router.ts"
      to: "src/audit/logger.ts"
      via: "auditLogger.append with category api_access"
      pattern: "auditLogger.*append.*api_access"
---

<objective>
Wire `neuron stop` to IPC shutdown and add `api_access` audit events to REST API router.

Purpose: Close two tech debt gaps from v1.0 milestone audit — the stop command is a stub (FOUN-06) and the `api_access` audit category has no producer (AUDT-02).
Output: Working `neuron stop` command that sends IPC shutdown signal, and REST API router that emits `api_access` audit events on auth success, auth failure, and rate limiting.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-foundation-tech-debt/08-CONTEXT.md
@.planning/phases/08-foundation-tech-debt/08-RESEARCH.md

@src/ipc/protocol.ts
@src/ipc/client.ts
@src/ipc/server.ts
@src/cli/commands/stop.ts
@src/cli/commands/start.ts
@src/cli/commands/status.ts
@src/api/router.ts
@src/audit/logger.ts
@src/cli/cli.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire IPC shutdown command and rewrite stop CLI</name>
  <files>
    src/ipc/protocol.ts
    src/cli/commands/stop.ts
    src/cli/commands/start.ts
    src/cli/cli.test.ts
  </files>
  <action>
  1. **Add shutdown command to IPC protocol** (`src/ipc/protocol.ts`):
     - Add `Type.Object({ type: Type.Literal('shutdown') })` to the `IpcCommandSchema` union array (alongside existing provider.add, provider.remove, provider.list, status, relationship.terminate)

  2. **Add shutdown handler to start command** (`src/cli/commands/start.ts`):
     - In the `ipcHandler` switch statement, add a `case 'shutdown':` block
     - The handler MUST: (a) return `{ ok: true, data: { message: 'Shutting down' } }` immediately so the IPC client receives the response, (b) then schedule shutdown via `setTimeout(() => void shutdown(), 100)` to ensure the response flushes over the socket before the process exits
     - Also add a `neuron_stop` admin audit event before shutdown begins (symmetry with existing `neuron_start` event in the same file): `auditLogger?.append({ category: 'admin', action: 'neuron_stop' })`

  3. **Rewrite stop command** (`src/cli/commands/stop.ts`):
     - Replace the entire stub with a real IPC-based command following the exact pattern from `status.ts`
     - Add `--config <path>` option (default: `'neuron.config.json'`), same as status command
     - Load config to derive socket path: `const config = loadConfig(options.config)` -> `getSocketPath(config.storage.path)`, with fallback to `getSocketPath('./data/neuron.db')` on config load failure
     - Send IPC command: `await sendIpcCommand(socketPath, { type: 'shutdown' } as IpcCommand)`
     - On success (`response.ok`): print `output.info('Neuron stopped')` and exit 0
     - On IPC error (catch block — ENOENT/ECONNREFUSED): print `output.info('Neuron is not running')` and exit 0 (idempotent stop)
     - On server error (`!response.ok`): print `output.error(response.error)` and exit 1
     - Import `sendIpcCommand`, `getSocketPath` from `../../ipc/index.js`, `loadConfig` from `../../config/index.js`, `output` from `../output.js`, and cast the command with `as IpcCommand` since TypeScript needs the discriminated union type

  4. **Add unit tests** (`src/cli/cli.test.ts`):
     - Add a `describe('stop command', ...)` block with 3 tests:
       (a) `should send shutdown IPC command`: mock `sendIpcCommand` to return `{ ok: true }`, parse `['node', 'neuron', 'stop']`, verify `sendIpcCommand` was called with `{ type: 'shutdown' }`
       (b) `should show "not running" when server is not running`: mock `sendIpcCommand` to reject with ENOENT error, verify stdout contains 'Neuron is not running', verify `process.exit` was NOT called with 1
       (c) `should handle server error`: mock `sendIpcCommand` to return `{ ok: false, error: 'Shutdown failed' }`, verify stderr contains 'Shutdown failed', verify `process.exit` was called with 1
     - Follow the exact test pattern from the existing `describe('status command', ...)` block
  </action>
  <verify>
  Run: `npx vitest run src/cli/cli.test.ts`
  All stop command tests pass. Existing tests still pass.
  Run: `npx vitest run src/ipc/ipc.test.ts`
  IPC tests still pass (shutdown is a new command type, no conflict).
  </verify>
  <done>
  `neuron stop` sends `{ type: 'shutdown' }` via IPC. Server handler responds ok, logs audit event, then triggers graceful shutdown. If server not running, stop prints friendly message and exits 0. Three new unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add api_access audit events to REST API router</name>
  <files>
    src/api/router.ts
    src/cli/commands/start.ts
    src/api/router.test.ts
  </files>
  <action>
  1. **Add auditLogger to ApiRouterDeps** (`src/api/router.ts`):
     - Add `auditLogger?: AuditLogger` to the `ApiRouterDeps` interface
     - Import `AuditLogger` type from `../audit/logger.js`

  2. **Add audit events in the router pipeline** (`src/api/router.ts`):
     Three audit points in `createApiRouter`:

     (a) **Auth failure** — after the `sendJson(res, 401, ...)` calls (both missing key and invalid key):
     ```typescript
     if (deps.auditLogger) {
       deps.auditLogger.append({
         category: 'api_access',
         action: 'auth_failure',
         details: { method, path: pathname, reason: 'missing_key' | 'invalid_key' },
       })
     }
     ```

     (b) **Rate limit exceeded** — after the `sendJson(res, 429, ...)` call:
     ```typescript
     if (deps.auditLogger) {
       deps.auditLogger.append({
         category: 'api_access',
         action: 'rate_limited',
         details: { method, path: pathname, key_id: keyRecord.key_id },
       })
     }
     ```

     (c) **Successful API request** — after the `method !== 'GET'` check and before route dispatch (so it covers all authenticated, rate-limited, valid-method requests):
     ```typescript
     if (deps.auditLogger) {
       deps.auditLogger.append({
         category: 'api_access',
         action: 'api_request',
         details: { method, path: pathname, key_id: keyRecord.key_id },
       })
     }
     ```

  3. **Pass auditLogger to createApiRouter** (`src/cli/commands/start.ts`):
     - In the `createApiRouter` call, add `auditLogger` to the deps object (it's already in scope from the audit logging initialization above)

  4. **Add unit tests** for audit events:
     - Check if `src/api/router.test.ts` exists. If it does, add tests there. If not, add a small test section in `src/cli/cli.test.ts` or create a new test file.
     - Test that auth failure, rate limit exceeded, and successful request each trigger `auditLogger.append` with the correct category and action
     - Use a mock AuditLogger: `{ append: vi.fn() }` passed in deps
  </action>
  <verify>
  Run: `npx vitest run src/api/` to verify API tests pass.
  Run: `npx vitest run src/cli/cli.test.ts` to verify CLI integration tests pass.
  Run: `npx vitest run` to verify all tests pass.
  Grep: `grep -r "category: 'api_access'" src/` should show 3 occurrences in router.ts.
  </verify>
  <done>
  REST API router emits `api_access` audit events for auth_failure, rate_limited, and api_request. AuditLogger passed through from start.ts to createApiRouter. All 6 non-deferred audit categories (registration, connection, consent, api_access, admin, termination) now have production producers. Unit tests verify audit event emission.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests pass (existing + new stop command + new audit tests)
2. `grep -r "category:" src/ --include="*.ts" | grep -v test | sort` shows all 6 categories: registration, connection, consent, api_access, admin, termination
3. `grep "Type.Literal('shutdown')" src/ipc/protocol.ts` confirms shutdown in IPC schema
4. `grep "sendIpcCommand" src/cli/commands/stop.ts` confirms stop uses IPC
</verification>

<success_criteria>
- `neuron stop` sends IPC shutdown command to running Neuron
- IPC handler responds, logs admin audit event, and triggers graceful shutdown
- Stop command exits 0 when server is not running (idempotent)
- REST API router emits api_access audit events for auth_failure, rate_limited, api_request
- All 6 non-deferred audit categories have production producers
- All existing tests continue to pass
- New unit tests cover stop command and audit event emission
</success_criteria>

<output>
After completion, create `.planning/phases/08-foundation-tech-debt/08-01-SUMMARY.md`
</output>
