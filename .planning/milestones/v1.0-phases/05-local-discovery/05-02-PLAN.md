---
phase: 05-local-discovery
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/cli/commands/start.ts
  - src/cli/commands/discover.ts
  - src/cli/index.ts
  - src/cli/cli.test.ts
autonomous: true
requirements: [DISC-03, DISC-04]

must_haves:
  truths:
    - "When localNetwork.enabled is true, neuron start advertises _careagent-neuron._tcp via mDNS and logs the advertising interfaces"
    - "When the Neuron shuts down (SIGINT/SIGTERM), the mDNS advertisement is gracefully removed before process exit"
    - "When localNetwork.enabled is false, no mDNS activity occurs and an info-level log indicates discovery is disabled"
    - "neuron discover command browses the local network for _careagent-neuron._tcp services and displays results"
    - "A local CareAgent connecting via the mDNS-advertised endpoint goes through the same consent handshake as a remote connection"
  artifacts:
    - path: "src/cli/commands/start.ts"
      provides: "DiscoveryService lifecycle integration in neuron start"
      contains: "DiscoveryService"
    - path: "src/cli/commands/discover.ts"
      provides: "neuron discover CLI command for network scanning"
      exports: ["registerDiscoverCommand"]
    - path: "src/cli/index.ts"
      provides: "Updated CLI with discover command registration"
      contains: "registerDiscoverCommand"
    - path: "src/cli/cli.test.ts"
      provides: "Updated CLI tests covering discovery lifecycle"
  key_links:
    - from: "src/cli/commands/start.ts"
      to: "src/discovery/service.ts"
      via: "import { DiscoveryService } from '../../discovery/index.js'"
      pattern: "new DiscoveryService"
    - from: "src/cli/commands/start.ts"
      to: "shutdown handler"
      via: "discoveryService.stop() in shutdown function"
      pattern: "discoveryService\\.stop\\(\\)"
    - from: "src/cli/commands/discover.ts"
      to: "bonjour-service"
      via: "import Bonjour from 'bonjour-service' for browsing"
      pattern: "bonjour\\.find"
---

<objective>
Wire the DiscoveryService into the Neuron startup/shutdown lifecycle and add the `neuron discover` CLI command for debugging.

Purpose: Complete the local discovery feature by integrating DiscoveryService into `neuron start` (auto-start/stop per DISC-03), logging which interfaces are advertising, and providing a CLI scan command for development/debugging. DISC-04 (same consent flow for local connections) is satisfied by design — local CareAgents connect to the same WebSocket endpoint advertised in TXT records, which routes through the existing `createConnectionHandler` with full consent verification.

Output: Updated start.ts with discovery lifecycle, discover.ts CLI command, updated CLI index, and updated tests.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-local-discovery/05-RESEARCH.md
@.planning/phases/05-local-discovery/05-CONTEXT.md
@.planning/phases/05-local-discovery/05-01-SUMMARY.md
@src/cli/commands/start.ts
@src/cli/index.ts
@src/cli/cli.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DiscoveryService into neuron start lifecycle</name>
  <files>src/cli/commands/start.ts</files>
  <action>
Import `DiscoveryService` and `os` module in start.ts:
```typescript
import { networkInterfaces } from 'node:os'
import { DiscoveryService } from '../../discovery/index.js'
```

**After the WebSocket server starts (step 6) and before Axon registration (step 7)**, add discovery startup:

```typescript
// 6b. Start local network discovery (if enabled)
let discoveryService: DiscoveryService | null = null
if (config.localNetwork.enabled) {
  const endpointUrl = `ws://${config.server.host === '0.0.0.0' ? getLocalAddress() : config.server.host}:${config.server.port}${config.websocket.path}`
  discoveryService = new DiscoveryService({
    enabled: true,
    serviceType: config.localNetwork.serviceType,
    protocolVersion: config.localNetwork.protocolVersion,
    organizationNpi: config.organization.npi,
    serverPort: config.server.port,
    endpointUrl,
  })
  await discoveryService.start()

  // Log advertising interfaces (user decision: info-level)
  const interfaces = networkInterfaces()
  for (const [name, addrs] of Object.entries(interfaces)) {
    if (!addrs) continue
    for (const addr of addrs) {
      if (!addr.internal && addr.family === 'IPv4') {
        output.info(`Advertising on ${name}: ${addr.address}`)
      }
    }
  }
  output.info(`Local discovery active: _${config.localNetwork.serviceType}._tcp`)
} else {
  output.info('Local network discovery disabled')
}
```

Add a helper function for getting a usable local address when server binds to 0.0.0.0:
```typescript
function getLocalAddress(): string {
  const interfaces = networkInterfaces()
  for (const addrs of Object.values(interfaces)) {
    if (!addrs) continue
    for (const addr of addrs) {
      if (!addr.internal && addr.family === 'IPv4') {
        return addr.address
      }
    }
  }
  return '127.0.0.1'
}
```

**In the shutdown handler**, add discovery stop BEFORE WebSocket server stop (discovery references the port info):

```typescript
const shutdown = async () => {
  clearInterval(keepAlive)

  // Stop local discovery first (sends goodbye packets)
  if (discoveryService) {
    try {
      await discoveryService.stop()
    } catch {
      // Ignore stop errors during shutdown
    }
  }

  // Stop WebSocket server (existing code)
  try {
    await protocolServer.stop()
  } catch {
    // Ignore stop errors during shutdown
  }
  // ... rest of existing shutdown
}
```

Discovery stops first in the shutdown pipeline because:
1. Goodbye packets tell LAN browsers the service is gone immediately
2. WebSocket server stays up briefly in case any final local connections are mid-handshake
3. Then WebSocket server closes, then registration, IPC, storage

**DISC-04 is satisfied by design:** The TXT `ep` record advertises the same WebSocket endpoint (`ws://host:port/ws/handshake`) that remote connections use. When a local CareAgent connects to this endpoint, the connection hits `NeuronProtocolServer.httpServer` upgrade handler, which routes to `createConnectionHandler` — the exact same consent verification, challenge-response, and relationship creation flow. No code changes needed in `src/routing/`.
  </action>
  <verify>
`pnpm build` succeeds. `pnpm test` passes (including existing CLI tests — may need CLI test mock updates for new DiscoveryService import).
  </verify>
  <done>
DiscoveryService is created and started during `neuron start` when `localNetwork.enabled` is true. Advertising interfaces are logged. Discovery stops first in shutdown pipeline. When disabled, an info message is logged and no mDNS activity occurs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create neuron discover CLI command</name>
  <files>src/cli/commands/discover.ts, src/cli/index.ts</files>
  <action>
Create `src/cli/commands/discover.ts`:

```typescript
import type { Command } from 'commander'
import Bonjour from 'bonjour-service'
import { output } from '../output.js'

export function registerDiscoverCommand(program: Command): void {
  program
    .command('discover')
    .description('Scan local network for Neuron services via mDNS')
    .option('-t, --timeout <ms>', 'scan duration in milliseconds', '3000')
    .option('--type <service>', 'service type to browse', 'careagent-neuron')
    .action((options: { timeout: string; type: string }) => {
      const timeoutMs = parseInt(options.timeout, 10)
      if (isNaN(timeoutMs) || timeoutMs < 500) {
        output.error('Timeout must be at least 500ms')
        process.exit(1)
        return
      }

      output.info(`Scanning for _${options.type}._tcp services (${timeoutMs}ms)...`)

      const bonjour = new Bonjour()
      const browser = bonjour.find({ type: options.type })
      let found = 0

      browser.on('up', (service) => {
        found++
        const txt = service.txt as Record<string, string> | undefined
        output.info('')
        output.success(`${service.name}`)
        output.info(`  NPI:      ${txt?.npi ?? 'unknown'}`)
        output.info(`  Version:  ${txt?.ver ?? 'unknown'}`)
        output.info(`  Endpoint: ${txt?.ep ?? 'unknown'}`)
        output.info(`  Host:     ${service.host}:${service.port}`)
      })

      setTimeout(() => {
        browser.stop()
        bonjour.destroy()
        output.info('')
        if (found === 0) {
          output.info('No Neuron services found on the local network')
        } else {
          output.info(`Found ${found} Neuron service(s)`)
        }
      }, timeoutMs)
    })
}
```

Key design decisions:
- **One-shot mode** with configurable timeout (default 3s). Per user context, scan command mode is Claude's discretion — one-shot is simpler and sufficient for debugging.
- `--timeout` flag for adjusting scan duration
- `--type` flag defaults to `careagent-neuron` but configurable for testing
- Uses the existing `output` helper for consistent CLI formatting
- Cleans up bonjour instance after scan completes

Register in `src/cli/index.ts`:
```typescript
import { registerDiscoverCommand } from './commands/discover.js'
// ... after existing command registrations
registerDiscoverCommand(program)
```
  </action>
  <verify>
`pnpm build` succeeds. `pnpm test` passes. Running `pnpm tsx src/cli/index.ts discover --help` shows the discover command with options.
  </verify>
  <done>
`neuron discover` command exists with `--timeout` and `--type` options. It scans the local network for `_careagent-neuron._tcp` services, displays NPI/version/endpoint/host for each found service, and reports total count.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update CLI tests for discovery integration</name>
  <files>src/cli/cli.test.ts</files>
  <action>
Update existing CLI tests to account for the new DiscoveryService import in start.ts:

1. **Mock the discovery module** alongside existing routing mock:
```typescript
vi.mock('../discovery/index.js', () => ({
  DiscoveryService: vi.fn().mockImplementation(() => ({
    start: vi.fn().mockResolvedValue(undefined),
    stop: vi.fn().mockResolvedValue(undefined),
  })),
}))
```

This prevents actual mDNS activity during CLI unit tests (same pattern as routing mock).

2. **Add test: start command logs discovery disabled when localNetwork.enabled is false** — verify that `output.info` was called with 'Local network discovery disabled'. The default config has `localNetwork.enabled: false`, so existing start tests should already exercise this path.

3. **Add test: discover command is registered** — verify `program.commands` includes a command named 'discover'. Follow existing pattern for command registration tests.

4. **Update any existing start command tests** that construct full config objects to include the new `localNetwork` fields:
```typescript
localNetwork: { enabled: false, serviceType: 'careagent-neuron', protocolVersion: 'v1.0' },
```

Ensure ALL existing tests continue to pass — the new fields with defaults should not break existing test configs, but verify explicitly.
  </action>
  <verify>
`pnpm test src/cli/cli.test.ts` — all tests pass (existing + new). `pnpm test` — full suite passes with no regressions.
  </verify>
  <done>
CLI tests mock the discovery module for isolation. Start command test verifies discovery-disabled log message. Discover command registration is tested. All existing CLI tests pass with updated config objects.
  </done>
</task>

</tasks>

<verification>
- [ ] `neuron start` with `localNetwork.enabled: true` creates DiscoveryService and calls start()
- [ ] `neuron start` with `localNetwork.enabled: false` logs "Local network discovery disabled" and creates no mDNS activity
- [ ] Advertising interfaces logged at info level (non-internal IPv4 addresses)
- [ ] Shutdown handler calls discoveryService.stop() before protocolServer.stop()
- [ ] `neuron discover` scans and displays found services with NPI, version, endpoint, host
- [ ] `neuron discover --timeout 5000` uses custom timeout
- [ ] Local connections to the advertised endpoint use the same consent handshake (verified by design — same WebSocket path, same handler)
- [ ] All existing tests pass with no regressions
- [ ] `pnpm build` succeeds
</verification>

<success_criteria>
The full local discovery feature is integrated into the Neuron lifecycle. Starting with `localNetwork.enabled: true` advertises via mDNS. Stopping sends goodbye packets. The `neuron discover` CLI command provides network scanning for debugging. Local CareAgent connections use the same consent-verified handshake as remote connections (DISC-04 by design). All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/05-local-discovery/05-02-SUMMARY.md`
</output>
