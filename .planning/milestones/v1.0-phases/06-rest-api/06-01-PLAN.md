---
phase: 06-rest-api
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/api/keys.ts
  - src/api/rate-limiter.ts
  - src/api/http-utils.ts
  - src/api/index.ts
  - src/types/config.ts
  - src/storage/migrations.ts
  - src/api/api-keys.test.ts
autonomous: true
requirements:
  - TAPI-02
  - TAPI-03

must_haves:
  truths:
    - "API keys can be generated with nrn_ prefix and stored as SHA-256 hashes"
    - "API key verification returns the key record for valid keys and undefined for invalid/revoked keys"
    - "Rate limiter tracks per-key token buckets and rejects when exhausted"
    - "NeuronConfig includes api section with rateLimit and cors settings"
  artifacts:
    - path: "src/api/keys.ts"
      provides: "ApiKeyStore with create, verify, revoke, list operations"
      exports: ["ApiKeyStore", "generateApiKey", "hashApiKey"]
    - path: "src/api/rate-limiter.ts"
      provides: "TokenBucketRateLimiter with consume and retryAfter"
      exports: ["TokenBucketRateLimiter"]
    - path: "src/api/http-utils.ts"
      provides: "sendJson and readBody utilities matching Axon pattern"
      exports: ["sendJson", "readBody"]
    - path: "src/types/config.ts"
      provides: "Extended NeuronConfig with api section"
      contains: "api:"
    - path: "src/storage/migrations.ts"
      provides: "Migration v4 creating api_keys table"
      contains: "api_keys"
  key_links:
    - from: "src/api/keys.ts"
      to: "src/storage/interface.ts"
      via: "StorageEngine SQL operations"
      pattern: "storage\\.run|storage\\.get|storage\\.all"
---

<objective>
Create the API key data layer and rate limiter that all REST endpoints depend on.

Purpose: TAPI-02 requires API key authentication and TAPI-03 requires rate limiting. Both are prerequisites for every REST endpoint. This plan establishes the data model, key generation/verification, rate limiting logic, and HTTP utility functions (matching Axon patterns).

Output: ApiKeyStore (SQLite-backed), TokenBucketRateLimiter (in-memory per-key), HTTP utilities, config extension, migration v4.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rest-api/06-RESEARCH.md
@src/storage/interface.ts
@src/storage/migrations.ts
@src/types/config.ts
@src/registration/state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config extension, migration v4, and HTTP utilities</name>
  <files>
    src/types/config.ts
    src/storage/migrations.ts
    src/api/http-utils.ts
    src/api/index.ts
  </files>
  <action>
**Config extension (`src/types/config.ts`):**
Add `api` section to NeuronConfigSchema:
```typescript
api: Type.Object({
  rateLimit: Type.Object({
    maxRequests: Type.Number({ minimum: 1, default: 100 }),
    windowMs: Type.Number({ minimum: 1000, default: 60000 }),
  }),
  cors: Type.Object({
    allowedOrigins: Type.Array(Type.String(), { default: [] }),
  }),
}),
```
This makes API rate limiting and CORS configurable per Neuron instance.

**Migration v4 (`src/storage/migrations.ts`):**
Add migration version 4 to the `migrations` array:
```sql
CREATE TABLE IF NOT EXISTS api_keys (
  key_id TEXT PRIMARY KEY,
  key_hash TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  created_at TEXT NOT NULL,
  revoked_at TEXT,
  last_used_at TEXT
);
CREATE INDEX IF NOT EXISTS idx_api_keys_hash ON api_keys(key_hash);
```
Description: `'Create api_keys table for REST API authentication'`

**HTTP utilities (`src/api/http-utils.ts`):**
Create `sendJson` and `readBody` functions matching Axon's exact pattern from `/Users/medomatic/Documents/Projects/axon/src/mock/server.ts`:
- `sendJson(res: ServerResponse, statusCode: number, data: unknown): void` — sets Content-Type: application/json, writes JSON, ends response
- `readBody(req: IncomingMessage): Promise<string>` — collects request body chunks into a string

**Barrel export (`src/api/index.ts`):**
Create barrel re-exporting from `keys.ts`, `rate-limiter.ts`, `http-utils.ts`.
  </action>
  <verify>
`pnpm run lint` passes (TypeScript compilation). Verify migration array has 4 entries. Verify NeuronConfigSchema includes api.rateLimit and api.cors.
  </verify>
  <done>
NeuronConfig type includes api.rateLimit.maxRequests, api.rateLimit.windowMs, api.cors.allowedOrigins. Migration v4 creates api_keys table with key_id, key_hash, name, created_at, revoked_at, last_used_at. sendJson and readBody utilities exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: ApiKeyStore and TokenBucketRateLimiter (TDD)</name>
  <files>
    src/api/keys.ts
    src/api/rate-limiter.ts
    src/api/api-keys.test.ts
  </files>
  <action>
**TDD: Write tests first, then implement.**

**Test file (`src/api/api-keys.test.ts`):**

RED tests for ApiKeyStore:
1. `generateApiKey()` returns `{ raw, hash }` where raw starts with `nrn_` and hash is 64-char hex
2. `hashApiKey(raw)` produces same hash as generateApiKey returned
3. `store.create(name)` inserts a key and returns `{ keyId, raw, name, createdAt }`
4. `store.verify(rawKey)` returns key record for valid key, updates last_used_at
5. `store.verify(rawKey)` returns undefined for unknown key
6. `store.verify(rawKey)` returns undefined for revoked key
7. `store.revoke(keyId)` sets revoked_at, subsequent verify returns undefined
8. `store.list()` returns all keys (without raw key or hash exposed)
9. Timing-safe comparison: `store.verify` uses `crypto.timingSafeEqual` (verify by checking that verification works correctly with correct and incorrect keys)

RED tests for TokenBucketRateLimiter:
1. `consume(keyId)` returns true for first request (within limit)
2. After `maxTokens` calls, `consume(keyId)` returns false
3. Different keyIds have independent buckets
4. After waiting > windowMs, tokens refill
5. `retryAfter(keyId)` returns seconds until next token
6. Cleanup removes stale buckets

**Implementation (`src/api/keys.ts`):**

`generateApiKey()`: Use `crypto.randomBytes(32)`, format as `nrn_${bytes.toString('base64url')}`, compute SHA-256 hash.

`hashApiKey(raw: string)`: `crypto.createHash('sha256').update(raw).digest('hex')`.

`ApiKeyStore` class:
- Constructor takes `StorageEngine`
- `create(name: string)`: generates key, inserts hash + metadata, returns `{ keyId, raw, name, createdAt }` (raw shown ONCE to user)
- `verify(rawKey: string)`: hashes the key, queries by hash, uses `crypto.timingSafeEqual` on Buffer.from(hash, 'hex') comparison, returns record or undefined. Updates `last_used_at` on success. Returns undefined if `revoked_at` is set.
- `revoke(keyId: string)`: sets `revoked_at = new Date().toISOString()`
- `list()`: returns all keys with `key_id, name, created_at, revoked_at, last_used_at` (NO hash, NO raw key)

Follow RegistrationStateStore pattern from `src/registration/state.ts` for StorageEngine usage.

**Implementation (`src/api/rate-limiter.ts`):**

`TokenBucketRateLimiter` class:
- Constructor: `(maxTokens: number, refillRate: number, windowMs: number)`
- `consume(keyId: string): boolean` — creates bucket if needed, refills based on elapsed time, decrements token or returns false
- `retryAfter(keyId: string): number` — seconds until next token available
- Internal: `Map<string, { tokens: number, lastRefill: number, lastAccess: number }>`
- Periodic cleanup method (called lazily): remove buckets with lastAccess > 10 minutes ago
  </action>
  <verify>
`pnpm test -- src/api/api-keys.test.ts` — all tests pass. Both RED (tests fail before implementation) and GREEN (tests pass after) phases completed.
  </verify>
  <done>
ApiKeyStore creates, verifies (timing-safe), revokes, and lists API keys with SHA-256 hashed storage. TokenBucketRateLimiter enforces per-key rate limits with configurable window and max. All operations tested.
  </done>
</task>

</tasks>

<verification>
- `pnpm test` passes (all existing + new tests)
- `pnpm run lint` passes (TypeScript compilation)
- Migration v4 creates api_keys table correctly
- NeuronConfig type includes api section
- ApiKeyStore CRUD operations work against real SQLite
- Rate limiter correctly limits and refills
</verification>

<success_criteria>
- API keys generated with nrn_ prefix, stored as SHA-256 hashes
- Timing-safe key verification (crypto.timingSafeEqual)
- Rate limiter enforces per-key token bucket limits
- Config extension adds api.rateLimit and api.cors
- Migration v4 adds api_keys table
- HTTP utilities match Axon sendJson/readBody pattern
</success_criteria>

<output>
After completion, create `.planning/phases/06-rest-api/06-01-SUMMARY.md`
</output>
