---
phase: 06-rest-api
plan: 03
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/cli/commands/api-key.ts
  - src/cli/commands/start.ts
  - src/cli/index.ts
  - src/cli/cli.test.ts
  - src/api/index.ts
autonomous: true
requirements:
  - TAPI-01
  - TAPI-07

must_haves:
  truths:
    - "neuron api-key create generates a new key and displays the raw key once"
    - "neuron api-key revoke removes an API key by ID"
    - "neuron api-key list shows all keys with status"
    - "neuron start wires REST API router to the HTTP server after WebSocket server starts"
    - "REST endpoints respond on the same port as WebSocket connections"
  artifacts:
    - path: "src/cli/commands/api-key.ts"
      provides: "CLI commands for API key management"
      exports: ["registerApiKeyCommand"]
    - path: "src/cli/commands/start.ts"
      provides: "Updated start command with REST API wiring"
      contains: "createApiRouter"
  key_links:
    - from: "src/cli/commands/api-key.ts"
      to: "src/api/keys.ts"
      via: "ApiKeyStore for key operations"
      pattern: "apiKeyStore\\.(create|revoke|list)"
    - from: "src/cli/commands/start.ts"
      to: "src/api/router.ts"
      via: "createApiRouter attached to HTTP server"
      pattern: "createApiRouter|protocolServer\\.server"
---

<objective>
Wire API key CLI commands and integrate the REST API router into the Neuron startup lifecycle.

Purpose: TAPI-07 requires CLI-based API key management (`neuron api-key create/revoke/list`). TAPI-01 requires the HTTP server to serve REST endpoints. This plan connects the API layer to the running Neuron by: (1) adding api-key CLI commands that manage keys via direct SQLite access, and (2) modifying the start command to attach the REST router to the existing HTTP server after the WebSocket server starts.

Output: Working `neuron api-key create/revoke/list` commands, REST API serving on same port as WebSocket.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rest-api/06-RESEARCH.md
@.planning/phases/06-rest-api/06-01-SUMMARY.md
@src/cli/commands/start.ts
@src/cli/commands/provider.ts
@src/cli/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: API key CLI commands</name>
  <files>
    src/cli/commands/api-key.ts
    src/cli/index.ts
  </files>
  <action>
**API key commands (`src/cli/commands/api-key.ts`):**

Create `registerApiKeyCommand(program: Command)` following the exact pattern from `src/cli/commands/provider.ts`.

API key commands work OFFLINE (direct SQLite access, no IPC to running server). This is because:
- Keys are stored in SQLite, accessible directly
- No need for the Neuron to be running to manage keys
- Consistent with how keys are managed in similar systems

**`neuron api-key create`:**
```typescript
program
  .command('api-key')
  .description('Manage REST API keys')
  .command('create')
  .description('Create a new API key')
  .requiredOption('--name <name>', 'Name/label for this API key')
  .option('-c, --config <path>', 'configuration file path', 'neuron.config.json')
  .action(async (options: { name: string; config: string }) => {
    // Load config to get storage path
    const config = loadConfig(options.config)
    const storage = new SqliteStorage(config.storage.path)
    storage.initialize()
    const apiKeyStore = new ApiKeyStore(storage)

    const result = apiKeyStore.create(options.name)

    output.success('API key created')
    output.info(`Key ID: ${result.keyId}`)
    output.info(`API Key: ${result.raw}`)
    output.warn('Save this key now — it cannot be retrieved later')

    storage.close()
  })
```

**`neuron api-key revoke`:**
```typescript
.command('revoke')
.description('Revoke an API key')
.argument('<key-id>', 'Key ID to revoke')
.option('-c, --config <path>', 'configuration file path', 'neuron.config.json')
.action(async (keyId: string, options: { config: string }) => {
  const config = loadConfig(options.config)
  const storage = new SqliteStorage(config.storage.path)
  storage.initialize()
  const apiKeyStore = new ApiKeyStore(storage)

  apiKeyStore.revoke(keyId)
  output.success(`API key ${keyId} revoked`)

  storage.close()
})
```

**`neuron api-key list`:**
```typescript
.command('list')
.description('List all API keys')
.option('-c, --config <path>', 'configuration file path', 'neuron.config.json')
.action(async (options: { config: string }) => {
  const config = loadConfig(options.config)
  const storage = new SqliteStorage(config.storage.path)
  storage.initialize()
  const apiKeyStore = new ApiKeyStore(storage)

  const keys = apiKeyStore.list()
  if (keys.length === 0) {
    output.info('No API keys')
    storage.close()
    return
  }

  for (const key of keys) {
    const status = key.revoked_at ? 'REVOKED' : 'active'
    const lastUsed = key.last_used_at ?? 'Never'
    output.info(`${key.key_id}  ${key.name}  [${status}]  Last used: ${lastUsed}`)
  }

  storage.close()
})
```

**Register in CLI (`src/cli/index.ts`):**
Import and call `registerApiKeyCommand(program)` alongside existing command registrations.
  </action>
  <verify>
`pnpm run lint` passes. The api-key command group is registered in the CLI.
  </verify>
  <done>
`neuron api-key create --name "test"` generates and displays a new API key. `neuron api-key revoke <id>` revokes a key. `neuron api-key list` shows all keys with status. All commands use direct SQLite access (no running server required).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire REST API into start command and update CLI tests</name>
  <files>
    src/cli/commands/start.ts
    src/cli/cli.test.ts
  </files>
  <action>
**Start command update (`src/cli/commands/start.ts`):**

After the WebSocket server starts (after `await protocolServer.start(config.server.port)`), wire the REST API router:

```typescript
// 6a. Wire REST API router to HTTP server
const apiKeyStore = new ApiKeyStore(storage)
const rateLimiter = new TokenBucketRateLimiter(
  config.api.rateLimit.maxRequests,
  config.api.rateLimit.maxRequests,  // refill = max (full refill each window)
  config.api.rateLimit.windowMs,
)

const apiRouter = createApiRouter({
  config,
  apiKeyStore,
  rateLimiter,
  relationshipStore,
  registrationService,
  protocolServer,
})

// Attach to existing HTTP server (from NeuronProtocolServer)
// HTTP 'request' events are for regular HTTP requests
// HTTP 'upgrade' events are handled by WebSocket (already wired in protocolServer.start)
const httpServer = protocolServer.server!
httpServer.on('request', (req, res) => {
  apiRouter(req, res)
})

output.info(`REST API active on port ${config.server.port} (/v1/*)`)
```

Add imports for `ApiKeyStore`, `TokenBucketRateLimiter`, `createApiRouter` from `../../api/index.js`.

IMPORTANT: The REST router MUST be attached AFTER `protocolServer.start()` completes, because the HTTP server is created during start(). The `.server` getter returns null before start().

IMPORTANT: The `httpServer.on('request', ...)` handler only fires for regular HTTP requests, NOT for WebSocket upgrade requests. WebSocket upgrades are handled by the separate `httpServer.on('upgrade', ...)` listener already wired in NeuronProtocolServer. No conflict.

**Update shutdown pipeline:** No changes needed -- the REST API is stateless (no connections to close). The HTTP server shutdown in protocolServer.stop() handles everything. Rate limiter is in-memory and garbage-collected.

**CLI tests update (`src/cli/cli.test.ts`):**

Add test cases for the api-key subcommands following the existing pattern:
1. `neuron api-key create --name test` — verify it creates a key (mock storage)
2. `neuron api-key list` — verify it lists keys
3. `neuron api-key revoke <id>` — verify it revokes a key

Mock the api module (`vi.mock('../../api/index.js', ...)`) to prevent actual SQLite operations in CLI unit tests, consistent with how routing module is mocked for start command tests.

Also update existing start command tests: mock the api module to prevent createApiRouter from requiring real dependencies. The mock should return a no-op function for createApiRouter.
  </action>
  <verify>
`pnpm test -- src/cli/cli.test.ts` — all tests pass (existing + new api-key tests). `pnpm run lint` passes.
  </verify>
  <done>
REST API router attached to HTTP server in start command lifecycle (after WebSocket, before Axon registration). API key CLI commands work for create/revoke/list. Same port serves both WebSocket upgrades and REST requests. CLI tests updated with api-key coverage and api module mocks.
  </done>
</task>

</tasks>

<verification>
- `pnpm test` passes (all existing + new tests)
- `pnpm run lint` passes
- `neuron api-key create --name test` generates and displays key
- `neuron api-key revoke <id>` revokes key
- `neuron api-key list` shows keys with status
- REST API serves on same port as WebSocket
- No conflict between WebSocket upgrade and REST request handlers
</verification>

<success_criteria>
- CLI api-key commands manage keys via direct SQLite access
- REST router wired into start command after protocolServer.start()
- Same port serves WebSocket (upgrade) and REST (request) traffic
- Shutdown pipeline unchanged (REST is stateless)
- CLI tests cover api-key commands and start command REST wiring
</success_criteria>

<output>
After completion, create `.planning/phases/06-rest-api/06-03-SUMMARY.md`
</output>
