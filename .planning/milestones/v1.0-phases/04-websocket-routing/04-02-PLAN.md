---
phase: 04-websocket-routing
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/routing/server.ts
  - src/routing/handler.ts
  - src/routing/session.ts
  - src/routing/index.ts
  - package.json
autonomous: true
requirements: [ROUT-01, ROUT-02, ROUT-03, ROUT-04, ROUT-05]

must_haves:
  truths:
    - "A WebSocket connection to /ws/handshake is accepted and upgraded correctly"
    - "A patient CareAgent sending a valid consent token as the first message receives a challenge, can respond, and receives handshake.complete with relationship_id and provider_endpoint"
    - "A connection that sends no message within 10 seconds receives handshake.error with AUTH_TIMEOUT and is closed"
    - "When maxConcurrentHandshakes is reached, new connections are queued (not rejected) and processed when slots open"
    - "When the server stops, all active WebSocket connections are closed with code 1001"
    - "If a patient already has an active relationship with the target provider, the handshake returns the existing relationship_id without creating a duplicate"
  artifacts:
    - path: "src/routing/server.ts"
      provides: "NeuronProtocolServer implementing ProtocolServer interface"
      exports: ["NeuronProtocolServer"]
    - path: "src/routing/handler.ts"
      provides: "WebSocket connection handler orchestrating handshake flow"
      exports: ["createConnectionHandler"]
    - path: "src/routing/session.ts"
      provides: "HandshakeSessionManager tracking active connections"
      exports: ["HandshakeSessionManager"]
  key_links:
    - from: "src/routing/server.ts"
      to: "src/routing/handler.ts"
      via: "wss.on('connection') calls handler"
      pattern: "createConnectionHandler"
    - from: "src/routing/handler.ts"
      to: "src/consent/verifier.ts"
      via: "verifyConsentToken for auth message"
      pattern: "verifyConsentToken"
    - from: "src/routing/handler.ts"
      to: "src/relationships/handshake.ts"
      via: "ConsentHandshakeHandler for challenge-response"
      pattern: "ConsentHandshakeHandler"
    - from: "src/routing/handler.ts"
      to: "src/relationships/store.ts"
      via: "RelationshipStore for existing relationship lookup"
      pattern: "RelationshipStore"
    - from: "src/routing/server.ts"
      to: "src/routing/session.ts"
      via: "session tracking for concurrency ceiling and activeSessions()"
      pattern: "HandshakeSessionManager"
---

<objective>
Implement the WebSocket routing server that accepts patient CareAgent connections and orchestrates the consent handshake.

Purpose: This is the core of Phase 4 -- the Neuron's WebSocket server that performs consent-gated handshakes. Patient CareAgents connect, present consent tokens, complete challenge-response identity verification, and receive provider endpoint addresses. The Neuron then disconnects (broker-and-step-out model).

Output: NeuronProtocolServer class, connection handler, and session manager. The `ws` library is installed as a dependency.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-websocket-routing/04-CONTEXT.md
@.planning/phases/04-websocket-routing/04-RESEARCH.md
@.planning/phases/04-websocket-routing/04-01-SUMMARY.md
@src/routing/types.ts
@src/routing/messages.ts
@src/routing/errors.ts
@src/consent/verifier.ts
@src/consent/token.ts
@src/consent/challenge.ts
@src/relationships/handshake.ts
@src/relationships/store.ts
@src/types/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ws and build NeuronProtocolServer with safety ceiling and session tracking</name>
  <files>
    package.json
    src/routing/session.ts
    src/routing/server.ts
    src/routing/index.ts
  </files>
  <action>
**Step 1: Install ws library**
```bash
pnpm add ws
pnpm add -D @types/ws
```

**Step 2: Create src/routing/session.ts -- HandshakeSessionManager**

Manages the in-memory map of active handshake sessions. This is ephemeral state (handshakes last seconds, not minutes).

```typescript
import { randomUUID } from 'node:crypto';

/** Internal session state (includes WebSocket reference for cleanup) */
export interface InternalSession {
  id: string;
  patientAgentId: string;
  providerNpi: string;
  status: 'authenticating' | 'challenged' | 'completed' | 'failed';
  startedAt: string;
}

export class HandshakeSessionManager {
  private readonly sessions = new Map<string, InternalSession>();

  /** Create a new session, returns session ID */
  create(): InternalSession {
    const session: InternalSession = {
      id: randomUUID(),
      patientAgentId: '',
      providerNpi: '',
      status: 'authenticating',
      startedAt: new Date().toISOString(),
    };
    this.sessions.set(session.id, session);
    return session;
  }

  /** Get session by ID */
  get(id: string): InternalSession | undefined {
    return this.sessions.get(id);
  }

  /** Remove session (on disconnect or completion) */
  remove(id: string): boolean {
    return this.sessions.delete(id);
  }

  /** Current number of active sessions */
  get size(): number {
    return this.sessions.size;
  }

  /** All active sessions (for ProtocolServer.activeSessions()) */
  all(): InternalSession[] {
    return Array.from(this.sessions.values());
  }

  /** Clear all sessions (for shutdown) */
  clear(): void {
    this.sessions.clear();
  }
}
```

**Step 3: Create src/routing/server.ts -- NeuronProtocolServer**

Implements the `ProtocolServer` interface. Uses `ws` in `noServer` mode attached to a `node:http` server.

Constructor accepts:
- `config: NeuronConfig` (for websocket settings)
- `handshakeHandler: ConsentHandshakeHandler` (from Phase 3)
- `relationshipStore: RelationshipStore` (from Phase 3)
- `registrationService: AxonRegistrationService` (for provider endpoint lookup)
- `auditLogger?: AuditLogger` (for connection audit events)

Key implementation details:

1. **noServer mode:** Create `http.createServer()` and `new WebSocketServer({ noServer: true, maxPayload: config.websocket.maxPayloadBytes })`. Attach upgrade handler that routes `/ws/handshake` path to WebSocketServer. Reject other paths by destroying the socket.

2. **Safety ceiling with queuing (per user decision: "no patient CareAgent should ever be turned away"):**
   - Track active connections via `sessionManager.size`
   - When `sessionManager.size >= config.websocket.maxConcurrentHandshakes`, push the upgrade request `{ request, socket, head }` to a `pendingUpgrades` array
   - Set a queue timeout per pending entry. If not promoted within `config.websocket.queueTimeoutMs`, send HTTP 503 and destroy the raw socket
   - After a session completes/disconnects, call `tryProcessPending()` to promote queued connections
   - `wsClientError` handler on WebSocketServer to handle malformed upgrades (destroy the socket)

3. **start(port):** Returns a Promise that resolves when `httpServer.listen(port)` fires `listening` event. Also accept optional `httpServer` parameter (for Phase 7 reuse) -- if provided, skip creating a new one.

4. **stop():** Close all active WebSocket connections with code 1001 ("going away"). Destroy all pending queued sockets. Close WebSocketServer. Close HTTP server. Return Promise.

5. **activeSessions():** Map `sessionManager.all()` to `ProtocolSession[]` format.

6. **Connection event wiring:** On `wss.on('connection', ...)`, delegate to the handler (created in Task 2). Pass the session manager and dependencies.

7. **Expose httpServer via getter** for Phase 7 REST API reuse (per research pitfall #3).

Update `src/routing/index.ts` barrel exports to include NeuronProtocolServer and HandshakeSessionManager.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run` -- all existing tests still pass. Verify `ws` and `@types/ws` appear in package.json dependencies/devDependencies.
  </verify>
  <done>
    NeuronProtocolServer class implements ProtocolServer interface with start/stop/activeSessions. WebSocket server runs in noServer mode on /ws/handshake path. Safety ceiling queues connections when limit is reached. Session manager tracks active handshake connections. HTTP server exposed for Phase 7 reuse.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket connection handler for consent handshake flow</name>
  <files>
    src/routing/handler.ts
    src/routing/index.ts
  </files>
  <action>
Create `src/routing/handler.ts` -- the function called on each new WebSocket connection. Orchestrates the full consent handshake flow as a multi-step state machine.

**Factory function signature:**
```typescript
export function createConnectionHandler(deps: {
  config: NeuronConfig;
  handshakeHandler: ConsentHandshakeHandler;
  relationshipStore: RelationshipStore;
  sessionManager: HandshakeSessionManager;
  organizationNpi: string;
  neuronEndpointUrl: string;
  auditLogger?: AuditLogger;
}): (ws: WebSocket, request: IncomingMessage) => void;
```

**Connection handler flow (per research handshake sequence):**

1. **On connection:**
   - Create session via `sessionManager.create()` (status: 'authenticating')
   - Start auth timeout: `setTimeout` of `config.websocket.authTimeoutMs`. On timeout, send `handshake.error` with code `AUTH_TIMEOUT`, close with WebSocket close code 4001, remove session.
   - Register `ws.once('message', ...)` for the first message (auth message).
   - Register `ws.on('error', ...)` to clear timeout and clean up session.
   - Register `ws.on('close', ...)` to clear timeout and remove session from tracking. Call `onSessionEnd` callback (for server to call `tryProcessPending`).

2. **On first message (handshake.auth):**
   - Clear auth timeout.
   - Reject binary frames: if `typeof data !== 'string'`, send error and close. Per discretion: text frames only.
   - Parse JSON. Validate against `HandshakeAuthMessageSchema` (use `Value.Check` from TypeBox `Value` module, or manual field check for simplicity). If invalid, send `handshake.error` with code `INVALID_MESSAGE`, close.
   - Extract `consent_token_payload`, `consent_token_signature`, `patient_agent_id`, `patient_public_key`, `patient_endpoint`.
   - Update session: set `patientAgentId` from message.
   - **Check for existing active relationship:** Query `relationshipStore.findByPatient(patient_agent_id)`, filter for provider_npi matching the provider resolved from the consent token. If an active relationship exists, skip challenge-response, send `handshake.complete` with `status: 'existing'`, existing `relationship_id`, and provider endpoint. Close connection. Log audit event.
   - **If no existing relationship:** Use the existing `ConsentHandshakeHandler.startHandshake()` to begin challenge-response flow. This creates a pending challenge with nonce.
   - Send `handshake.challenge` message with nonce, provider_npi, organization_npi.
   - Update session status to 'challenged'.
   - Register `ws.once('message', ...)` for the challenge response.

3. **On second message (handshake.challenge_response):**
   - Parse JSON. Validate as `HandshakeChallengeResponseMessage`.
   - Build `ChallengeResponse` object combining `signed_nonce` from this message with `consent_token_payload` and `consent_token_signature` from the original auth message (held in closure).
   - Call `ConsentHandshakeHandler.completeHandshake(nonce, challengeResponse)` which:
     - Verifies challenge-response signature
     - Verifies consent token
     - Validates provider NPI match
     - Creates relationship record
     - Logs consent audit event
   - On success: update session status to 'completed'. Send `handshake.complete` with `relationship_id`, `provider_endpoint` (resolved from `deps.neuronEndpointUrl` + provider NPI path, e.g., `ws://{host}:{port}/ws/provider/{npi}`), and `status: 'new'`.
   - Close WebSocket with code 1000 (normal closure). Per CONTEXT.md: "Neuron disconnects -- no persistent session."
   - Log `connection.handshake_completed` audit event.
   - On failure (ConsentError or other): send `handshake.error` with appropriate code, close WebSocket. Log `connection.handshake_failed` audit event.

4. **Error handling:**
   - `ConsentError` from consent module: map error codes to handshake error codes (`INVALID_SIGNATURE` -> `CONSENT_FAILED`, `CONSENT_EXPIRED` -> `CONSENT_FAILED`, `MALFORMED_TOKEN` -> `INVALID_MESSAGE`).
   - Unexpected errors: send `handshake.error` with code `SERVER_ERROR`, do not leak internal details in message.

5. **Provider endpoint resolution:**
   - For now, construct as `{deps.neuronEndpointUrl}/ws/provider/{provider_npi}`. This is a placeholder that will be refined when Axon's protocol spec lands (per research open question #1).
   - If provider NPI is not found in registered providers, send error with code `PROVIDER_NOT_FOUND` and close.

6. **Helper:** `sendMessage(ws, message)` -- JSON.stringify and ws.send. `sendError(ws, code, message)` -- sends handshake.error and closes.

**Provider NPI resolution from consent token:**
The consent token claims include `provider_npi`. When the auth message arrives, we need to verify the consent token to extract claims, BUT the full verification happens in completeHandshake. For the existing-relationship check, we need the provider_npi early. Approach: do a quick consent token verification (re-verify is stateless per CSNT-02) to extract claims, use `claims.provider_npi` for the existing-relationship check, then proceed with challenge-response flow if needed. This means verifying the consent token twice (once here, once in completeHandshake), but that's fine -- it's a pure cryptographic operation with no side effects.

Update `src/routing/index.ts` to export `createConnectionHandler`.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run` -- all existing tests pass.
  </verify>
  <done>
    Connection handler implements full handshake flow: auth timeout -> first-message consent auth -> existing relationship check -> challenge-response -> address exchange -> disconnect. Error handling maps consent errors to handshake error codes. Provider endpoint resolved from registration state. Binary frames rejected. Text-only JSON envelopes used throughout.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npx vitest run` -- all existing 140+ tests pass (no regressions)
3. `pnpm list ws` shows ws installed
4. NeuronProtocolServer exports start/stop/activeSessions matching ProtocolServer interface
5. Connection handler orchestrates auth -> challenge -> complete -> close flow
6. Safety ceiling queues connections, does not reject them
7. Auth timeout fires after 10 seconds of no message
</verification>

<success_criteria>
- NeuronProtocolServer.start(port) creates HTTP+WS server on /ws/handshake
- NeuronProtocolServer.stop() closes all connections with code 1001
- NeuronProtocolServer.activeSessions() returns ProtocolSession array
- Connection handler implements full handshake flow per research sequence diagram
- Safety ceiling queues connections when maxConcurrentHandshakes reached
- Auth timeout sends error and closes connection after authTimeoutMs
- Existing active relationships return existing relationship_id without creating duplicate
- Binary frames rejected with error
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-websocket-routing/04-02-SUMMARY.md`
</output>
