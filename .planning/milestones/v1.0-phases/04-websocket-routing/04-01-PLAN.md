---
phase: 04-websocket-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/config.ts
  - src/config/defaults.ts
  - src/routing/types.ts
  - src/routing/messages.ts
  - src/routing/errors.ts
  - src/routing/index.ts
autonomous: true
requirements: [ROUT-01, ROUT-03, ROUT-04, ROUT-06]

must_haves:
  truths:
    - "WebSocket configuration section exists in NeuronConfig with maxConcurrentHandshakes, authTimeoutMs, queueTimeoutMs, maxPayloadBytes, and path"
    - "ProtocolServer and ProtocolSession interfaces are defined and exported for implementation"
    - "Handshake message types cover the full auth -> challenge -> challenge_response -> complete -> error flow"
    - "Routing error types provide structured error codes for handshake failures"
  artifacts:
    - path: "src/types/config.ts"
      provides: "WebSocket configuration section in NeuronConfigSchema"
      contains: "websocket"
    - path: "src/config/defaults.ts"
      provides: "Default values for websocket config"
      contains: "websocket"
    - path: "src/routing/types.ts"
      provides: "ProtocolServer and ProtocolSession interfaces"
      exports: ["ProtocolServer", "ProtocolSession"]
    - path: "src/routing/messages.ts"
      provides: "TypeBox schemas for all handshake message types"
      exports: ["HandshakeAuthMessageSchema", "HandshakeChallengeMessageSchema", "HandshakeCompleteMessageSchema", "HandshakeErrorMessageSchema"]
    - path: "src/routing/errors.ts"
      provides: "Routing error types with codes"
      exports: ["RoutingError", "RoutingErrorCode"]
    - path: "src/routing/index.ts"
      provides: "Barrel exports for routing module"
  key_links:
    - from: "src/types/config.ts"
      to: "src/config/defaults.ts"
      via: "websocket section defaults match schema"
      pattern: "websocket.*maxConcurrentHandshakes"
    - from: "src/routing/types.ts"
      to: "src/routing/messages.ts"
      via: "ProtocolSession status type used in message types"
      pattern: "ProtocolSession"
---

<objective>
Define all types, schemas, configuration, and message formats needed for WebSocket routing.

Purpose: Establish the type foundation that the WebSocket server (Plan 02) and CLI wiring (Plan 03) will implement against. Separating types into their own plan keeps the implementation plans focused on behavior, not schema definition.

Output: Config schema extended with `websocket` section, ProtocolServer/ProtocolSession interfaces, TypeBox handshake message schemas, and routing error types.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-websocket-routing/04-CONTEXT.md
@.planning/phases/04-websocket-routing/04-RESEARCH.md
@src/types/config.ts
@src/config/defaults.ts
@src/consent/token.ts
@src/types/registration.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend NeuronConfig with websocket section and add ProtocolServer types</name>
  <files>
    src/types/config.ts
    src/config/defaults.ts
    src/routing/types.ts
    src/routing/errors.ts
    src/routing/index.ts
  </files>
  <action>
1. **src/types/config.ts** -- Add a `websocket` section to `NeuronConfigSchema`:
   ```typescript
   websocket: Type.Object({
     path: Type.String({ default: '/ws/handshake' }),
     maxConcurrentHandshakes: Type.Number({ minimum: 1, default: 10 }),
     authTimeoutMs: Type.Number({ minimum: 1000, default: 10000 }),
     queueTimeoutMs: Type.Number({ minimum: 1000, default: 30000 }),
     maxPayloadBytes: Type.Number({ minimum: 1024, default: 65536 }),
   }),
   ```
   Place it after the `server` section. All defaults match research recommendations.

2. **src/config/defaults.ts** -- Add matching defaults:
   ```typescript
   websocket: {
     path: '/ws/handshake',
     maxConcurrentHandshakes: 10,
     authTimeoutMs: 10000,
     queueTimeoutMs: 30000,
     maxPayloadBytes: 65536,
   },
   ```

3. **src/routing/types.ts** -- Define ProtocolServer and ProtocolSession interfaces:
   ```typescript
   /** Session status for a handshake connection */
   export type HandshakeStatus = 'authenticating' | 'challenged' | 'completed' | 'failed';

   /** Active handshake session representation (satisfies ProtocolSession from provider-core) */
   export interface ProtocolSession {
     sessionId: string;
     patientAgentId: string;
     providerAgentId: string;
     startedAt: string;
     status: 'active' | 'completed' | 'terminated';
   }

   /** Protocol server interface (satisfies ProtocolServer from provider-core) */
   export interface ProtocolServer {
     start(port: number): Promise<void>;
     stop(): Promise<void>;
     activeSessions(): ProtocolSession[];
   }
   ```
   Also export a `HandshakeSession` interface for internal tracking:
   ```typescript
   import type { WebSocket } from 'ws';

   export interface HandshakeSession {
     id: string;
     ws: WebSocket;
     patientAgentId: string;
     providerNpi: string;
     status: HandshakeStatus;
     startedAt: string;
     authTimer: ReturnType<typeof setTimeout> | null;
   }
   ```
   NOTE: Do NOT import `ws` types here yet (ws is not installed). Instead, use `unknown` for the ws field and add a comment that Plan 02 will refine this after installing ws. Or better: make HandshakeSession generic or use a plain interface without the ws field (track ws separately in the server).

   **Revised approach for HandshakeSession** (avoid ws dependency):
   ```typescript
   export interface HandshakeSession {
     id: string;
     patientAgentId: string;
     providerNpi: string;
     status: HandshakeStatus;
     startedAt: string;
   }
   ```
   The WebSocket reference and auth timer will be tracked internally by the server (Plan 02), not in the exported type.

4. **src/routing/errors.ts** -- Define routing error codes and RoutingError class:
   ```typescript
   export type RoutingErrorCode =
     | 'AUTH_TIMEOUT'
     | 'INVALID_MESSAGE'
     | 'CONSENT_FAILED'
     | 'PROVIDER_NOT_FOUND'
     | 'RELATIONSHIP_EXISTS'
     | 'CEILING_TIMEOUT'
     | 'SERVER_ERROR';

   export class RoutingError extends Error {
     constructor(
       public readonly code: RoutingErrorCode,
       message: string,
     ) {
       super(message);
       this.name = 'RoutingError';
     }
   }
   ```

5. **src/routing/index.ts** -- Barrel exports:
   ```typescript
   export * from './types.js';
   export * from './messages.js';
   export * from './errors.js';
   ```
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run` -- all existing 140 tests still pass.
  </verify>
  <done>
    NeuronConfigSchema has a `websocket` section with all 5 fields and defaults. ProtocolServer, ProtocolSession, HandshakeSession, and RoutingError are exported from `src/routing/`. Existing tests unaffected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define handshake message TypeBox schemas with validation</name>
  <files>
    src/routing/messages.ts
  </files>
  <action>
Create `src/routing/messages.ts` with TypeBox schemas for the 5 handshake message types. Per user decision: consent token sent as first message, not in query params or headers. Per Claude's discretion (research recommendation): typed JSON envelopes with `type` field for dispatch, text frames only.

```typescript
import { Type, type Static } from '@sinclair/typebox';

/** Patient -> Neuron: Consent token submission (first message after connect) */
export const HandshakeAuthMessageSchema = Type.Object({
  type: Type.Literal('handshake.auth'),
  consent_token_payload: Type.String(),   // base64url-encoded
  consent_token_signature: Type.String(), // base64url-encoded
  patient_agent_id: Type.String(),
  patient_public_key: Type.String(),      // base64url raw 32-byte Ed25519 public key
  patient_endpoint: Type.String(),        // Where the patient CareAgent can be reached
});
export type HandshakeAuthMessage = Static<typeof HandshakeAuthMessageSchema>;

/** Neuron -> Patient: Challenge for identity verification */
export const HandshakeChallengeMessageSchema = Type.Object({
  type: Type.Literal('handshake.challenge'),
  nonce: Type.String(),
  provider_npi: Type.String(),
  organization_npi: Type.String(),
});
export type HandshakeChallengeMessage = Static<typeof HandshakeChallengeMessageSchema>;

/** Patient -> Neuron: Challenge response with signed nonce */
export const HandshakeChallengeResponseMessageSchema = Type.Object({
  type: Type.Literal('handshake.challenge_response'),
  signed_nonce: Type.String(), // base64url Ed25519 signature over nonce
});
export type HandshakeChallengeResponseMessage = Static<typeof HandshakeChallengeResponseMessageSchema>;

/** Neuron -> Patient: Handshake complete with address exchange */
export const HandshakeCompleteMessageSchema = Type.Object({
  type: Type.Literal('handshake.complete'),
  relationship_id: Type.String(),
  provider_endpoint: Type.String(), // Direct address for provider CareAgent
  status: Type.Union([
    Type.Literal('new'),       // New relationship created
    Type.Literal('existing'),  // Existing active relationship confirmed
  ]),
});
export type HandshakeCompleteMessage = Static<typeof HandshakeCompleteMessageSchema>;

/** Neuron -> Patient: Error response */
export const HandshakeErrorMessageSchema = Type.Object({
  type: Type.Literal('handshake.error'),
  code: Type.String(),
  message: Type.String(),
});
export type HandshakeErrorMessage = Static<typeof HandshakeErrorMessageSchema>;

/** Union of all inbound messages (patient -> neuron) */
export const InboundHandshakeMessageSchema = Type.Union([
  HandshakeAuthMessageSchema,
  HandshakeChallengeResponseMessageSchema,
]);
export type InboundHandshakeMessage = Static<typeof InboundHandshakeMessageSchema>;
```

Key design decisions:
- `patient_endpoint` in auth message: per CONTEXT.md, Neuron exchanges direct addresses. Patient provides its endpoint during auth.
- `provider_endpoint` in complete message: returned to patient for direct P2P communication.
- `status` field in complete message distinguishes new vs existing relationship (per research open question #2: if an active relationship already exists, skip creation and return existing).
- No `provider_npi` field in auth message: per CONTEXT.md locked decision, consent token already encodes the relationship and Neuron resolves the target provider from the token.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run` -- all 140 tests still pass.
  </verify>
  <done>
    All 5 handshake message TypeBox schemas defined and exported. InboundHandshakeMessage union covers patient-to-Neuron messages. Message format uses typed JSON envelopes with `type` field discriminator.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx vitest run` -- all 140+ existing tests pass (no regressions)
3. `src/routing/index.ts` exports ProtocolServer, ProtocolSession, HandshakeSession, RoutingError, RoutingErrorCode, and all message schemas
4. `src/types/config.ts` NeuronConfigSchema includes `websocket` section
5. `src/config/defaults.ts` includes matching websocket defaults
</verification>

<success_criteria>
- NeuronConfig type includes `websocket.path`, `websocket.maxConcurrentHandshakes`, `websocket.authTimeoutMs`, `websocket.queueTimeoutMs`, `websocket.maxPayloadBytes`
- ProtocolServer interface defines `start(port)`, `stop()`, `activeSessions()`
- All 5 handshake message types have TypeBox schemas with proper discriminant `type` fields
- Routing error codes cover all handshake failure modes
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-websocket-routing/04-01-SUMMARY.md`
</output>
