---
phase: 02-axon-registration
plan: 04
type: execute
wave: 3
depends_on: [02-02, 02-03]
files_modified:
  - src/cli/commands/provider.ts
  - src/cli/commands/start.ts
  - src/cli/commands/status.ts
  - src/cli/index.ts
  - src/cli/cli.test.ts
autonomous: true
requirements: [NREG-01, NREG-02, NREG-03, NREG-04, NREG-05, NREG-06]

must_haves:
  truths:
    - "On startup, neuron start registers the organization with Axon and starts heartbeat"
    - "neuron provider add <npi> contacts the running Neuron and registers the provider with Axon immediately"
    - "neuron provider remove <npi> confirms interactively before unregistering from Axon"
    - "neuron provider list shows a table with NPI, registration status, and last heartbeat time"
    - "neuron status shows registration state, Axon connectivity, and provider list"
    - "After restart, registration state is restored from SQLite without re-registering with Axon"
    - "When Axon is unreachable on startup, Neuron enters degraded mode and logs warnings"
  artifacts:
    - path: "src/cli/commands/provider.ts"
      provides: "neuron provider add|remove|list CLI commands"
      exports: ["registerProviderCommand"]
    - path: "src/cli/commands/start.ts"
      provides: "Enhanced start command with registration, IPC, and heartbeat"
    - path: "src/cli/commands/status.ts"
      provides: "Enhanced status command showing registration and heartbeat state"
    - path: "src/cli/index.ts"
      provides: "Updated CLI with provider command registered"
  key_links:
    - from: "src/cli/commands/provider.ts"
      to: "src/ipc/client.ts"
      via: "sendIpcCommand for hot provider management"
      pattern: "sendIpcCommand"
    - from: "src/cli/commands/start.ts"
      to: "src/registration/service.ts"
      via: "AxonRegistrationService lifecycle"
      pattern: "AxonRegistrationService"
    - from: "src/cli/commands/start.ts"
      to: "src/ipc/server.ts"
      via: "startIpcServer embedded in neuron start"
      pattern: "startIpcServer"
    - from: "src/cli/commands/status.ts"
      to: "src/ipc/client.ts"
      via: "sendIpcCommand for status query"
      pattern: "sendIpcCommand.*status"
---

<objective>
Wire the registration engine and IPC layer into the CLI, creating the full user-facing experience for Phase 2.

Purpose: This is the integration plan that connects all Phase 2 components: the `neuron start` command orchestrates registration + heartbeat + IPC server, the `neuron provider` commands manage providers through the running server, and `neuron status` reports the full system state.

Output: Working CLI commands that fulfill all Phase 2 success criteria from the roadmap.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-axon-registration/02-RESEARCH.md
@.planning/phases/02-axon-registration/02-02-SUMMARY.md
@.planning/phases/02-axon-registration/02-03-SUMMARY.md

@src/cli/commands/start.ts
@src/cli/commands/status.ts
@src/cli/index.ts
@src/cli/output.ts
@src/ipc/index.ts
@src/registration/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Provider CLI commands (add, remove, list)</name>
  <files>
    src/cli/commands/provider.ts
    src/cli/index.ts
  </files>
  <action>
1. Create `src/cli/commands/provider.ts`:
   - Import `sendIpcCommand`, `getSocketPath` from `../../ipc/index.js`
   - Import `isValidNpi` from `../../validators/npi.js`
   - Import `output` from `../output.js`
   - Import `createInterface` from `node:readline` (for interactive confirmation)
   - Import `loadConfig` from `../../config/index.js`
   - Export function `registerProviderCommand(program: Command): void`:
     - Create `provider` subcommand group: `program.command('provider').description('Manage providers')`

   **provider add <npi>:**
   - Validate NPI with `isValidNpi(npi)`. If invalid: `output.error('Invalid NPI: ${npi}')`, exit 1
   - Load config to derive socket path: `getSocketPath(config.storage.path)`
   - Call `sendIpcCommand(socketPath, { type: 'provider.add', npi })`
   - On success: `output.success('Provider ${npi} registered with Axon')`
   - On failure (response.ok === false): `output.error(response.error ?? 'Registration failed')`, exit 1
   - On connection error (IPC fails): `output.error('Could not connect to Neuron — is it running?')`, exit 1
   - Per locked decision: requires NPI only — minimal input. Takes effect immediately (hot).

   **provider list:**
   - Load config, derive socket path
   - Call `sendIpcCommand(socketPath, { type: 'provider.list' })`
   - On success: format data as table using `output.table()` with columns: NPI, Status, Last Heartbeat
   - Per locked decision: simple table with NPI, registration status, last heartbeat time
   - If no providers: `output.info('No providers registered')`
   - On connection error: `output.error('Could not connect to Neuron — is it running?')`, exit 1

   **provider remove <npi>:**
   - Validate NPI
   - Per locked decision: always confirm interactively before unregistering
   - Use `node:readline` to prompt: `Remove provider ${npi}? This will unregister from Axon. (y/N): `
   - If answer is not 'y' or 'Y': `output.info('Cancelled')`, return
   - Load config, derive socket path
   - Call `sendIpcCommand(socketPath, { type: 'provider.remove', npi })`
   - On success: `output.success('Provider ${npi} removed and unregistered from Axon')`
   - On failure: `output.error(response.error ?? 'Removal failed')`, exit 1
   - On connection error: same message as above

   For config loading in CLI commands: use a shared helper that reads the config file path from `--config` option on the parent program or defaults to `neuron.config.json`. Use `loadConfig` from config module. Wrap in try/catch — if config can't be loaded, fall back to default socket path `./data/neuron.sock`.

2. Update `src/cli/index.ts`:
   - Import `registerProviderCommand` from `./commands/provider.js`
   - Call `registerProviderCommand(program)` after existing command registrations
  </action>
  <verify>
    `pnpm build` compiles cleanly. Run `neuron provider --help` to verify all three subcommands (add, remove, list) are listed.
  </verify>
  <done>
    - `neuron provider add <npi>` validates NPI, contacts running Neuron via IPC, registers provider with Axon immediately
    - `neuron provider remove <npi>` prompts for confirmation (per locked decision), then unregisters
    - `neuron provider list` displays NPI, status, last heartbeat in table format
    - All three commands handle "server not running" gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhanced neuron start (registration + IPC + heartbeat) and neuron status</name>
  <files>
    src/cli/commands/start.ts
    src/cli/commands/status.ts
    src/cli/cli.test.ts
  </files>
  <action>
1. Enhance `src/cli/commands/start.ts`:
   - Keep existing Phase 1 startup pipeline (config -> storage -> audit)
   - After audit initialization, add these new steps:

   **Step 5: Start IPC server**
   - Import `startIpcServer`, `getSocketPath` from `../../ipc/index.js`
   - Derive socket path: `getSocketPath(config.storage.path)`
   - Create IPC handler function that routes commands:
     - `provider.add`: call `registrationService.addProvider(command.npi)`, return `{ ok: true, data: { npi: command.npi } }`
     - `provider.remove`: call `registrationService.removeProvider(command.npi)`, return `{ ok: true }`
     - `provider.list`: call `registrationService.listProviders()`, return `{ ok: true, data: providers }` (format providers with npi, status, last_heartbeat_at)
     - `status`: call `registrationService.getStatus()`, return `{ ok: true, data: statusInfo }`
     - Wrap each handler in try/catch: on error, return `{ ok: false, error: String(err) }`
   - Start IPC server: `const ipcServer = startIpcServer(socketPath, handler)`
   - Output: `output.info('IPC server listening: ${socketPath}')`

   **Step 6: Start Axon registration**
   - Import `AxonRegistrationService` from `../../registration/index.js`
   - Create service: `const registrationService = new AxonRegistrationService(config, storage, auditLogger)`
   - Call `await registrationService.start()`
   - On success: `output.success('Registered with Axon (ID: ${state.registration_id})')`
   - On failure (Axon unreachable): `output.warn('Axon unreachable — running in degraded mode, will retry')` — do NOT crash (per NREG-06)
   - The heartbeat is started internally by the service

   **Update shutdown handler:**
   - Stop registration service: `await registrationService.stop()` (stops heartbeat)
   - Close IPC server: `ipcServer.close()`
   - Remove socket file: `try { unlinkSync(socketPath) } catch {}`
   - Keep existing storage.close()

   **Important:** The `neuron start` action must be `async` now (it was sync in Phase 1). Update the Commander action to be `async (options) => { ... }`.

2. Enhance `src/cli/commands/status.ts`:
   - Replace the Phase 1 stub with a real implementation
   - Import `sendIpcCommand`, `getSocketPath` from `../../ipc/index.js`
   - Import `loadConfig`, `ConfigError` from `../../config/index.js`
   - Import `output` from `../output.js`
   - Load config (same pattern as provider commands)
   - Try to connect via IPC with `sendIpcCommand(socketPath, { type: 'status' })`
   - On success, display:
     ```
     Neuron Status
     Organization: {name} (NPI: {npi})
     Axon Registration: {registered|unregistered|pending|suspended}
     Registration ID: {id or 'N/A'}
     Heartbeat: {healthy|degraded}
     Last Heartbeat: {timestamp or 'Never'}
     Axon Connectivity: {reachable|unreachable}

     Providers:
     {table with NPI, Status, Last Heartbeat columns}
     ```
   - On IPC connection failure: `output.info('Neuron is not running')` (per research pattern 7)
   - Per locked decision: degraded state surfaced through neuron status command

3. Update `src/cli/cli.test.ts`:
   - Add integration tests for the enhanced start command:
     - Test that start command initializes AxonRegistrationService (mock the service)
     - Test that start command starts IPC server
     - Test graceful shutdown closes IPC server and stops registration service
   - Add integration tests for provider commands:
     - Test `neuron provider add` with valid NPI sends correct IPC command
     - Test `neuron provider add` with invalid NPI exits with error
     - Test `neuron provider list` formats table output
   - Add integration test for status:
     - Test `neuron status` when server is not running shows "not running" message
   - Note: These tests should mock IPC and registration service (do not start real servers in unit tests). Use vi.mock() for the ipc/client and registration/service modules.
  </action>
  <verify>
    `pnpm test` passes all tests. `pnpm build` compiles cleanly. Verify the full lifecycle manually:
    1. Start mock Axon: `npx tsx test/mock-axon/start.ts --port 9999 &`
    2. Create a config: `neuron init` then edit neuron.config.json to set axon.registryUrl to `http://localhost:9999`
    3. Start Neuron: `neuron start`
    4. In another terminal: `neuron status` shows registered state
    5. `neuron provider add 1234567893` registers provider
    6. `neuron provider list` shows provider in table
    7. Stop Neuron (Ctrl+C), restart, verify state is restored
  </verify>
  <done>
    - `neuron start` registers with Axon, starts heartbeat, opens IPC socket, handles provider management commands
    - `neuron status` shows full registration state, heartbeat status, Axon connectivity, and provider list
    - Provider CLI commands (add/remove/list) communicate with running Neuron via IPC for immediate effect
    - Graceful shutdown: heartbeat stopped, IPC server closed, socket file cleaned up, storage closed
    - Axon unreachable on startup enters degraded mode without crashing
    - Restart restores registration state from SQLite (no re-registration with Axon)
    - All Phase 2 roadmap success criteria are met
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` passes all tests (Phase 1 + Phase 2)
2. `pnpm build` compiles with no type errors
3. Manual end-to-end test against mock Axon:
   - `neuron start` registers with mock Axon and reports registered status
   - `neuron provider add/remove/list` works while server is running
   - `neuron status` shows complete registration and heartbeat state
   - Stopping and restarting preserves registration state
4. Heartbeat maintains reachable status (verify via mock Axon GET endpoint)
5. Graceful degradation: start Neuron without mock Axon running — enters degraded mode, does not crash
</verification>

<success_criteria>
- All 5 Phase 2 roadmap success criteria are met:
  1. On startup, Neuron registers with mock Axon and appears as reachable
  2. Providers can be added/removed/listed via CLI without restart
  3. Heartbeat keeps status reachable; stopping heartbeat marks unreachable
  4. After restart, registration state restored from storage without re-registration
  5. When Axon unreachable, Neuron continues operating and retries with backoff
- All tests pass with >80% coverage on new files
- Clean CLI experience matching locked decisions (minimal input, table output, interactive confirmation)
</success_criteria>

<output>
After completion, create `.planning/phases/02-axon-registration/02-04-SUMMARY.md`
</output>
